{"posts":[{"title":"Logisim视角下的Moore与Mealy状态机辨析","text":"BUAA_CO_P0有感 有限状态机表示有限个状态以及在这些状态之间的转移和动作等行为的数学统计模型。 有限状态机（FSM）组成部分 State : 系统可能处于的状态。每个状态反映的是系统的某个模式或环节。有限状态机的状态是有限的。 Input : 外部输入的信号，会影响状态的转换。 Output : 状态机在特定条件下输出的信号。 Transitions : 系统根据状态转移函数从一个状态转移到另一个状态。 Initial State : 系统的初始状态。 例题（字符串匹配）在了解有限状态机的两种类型前，我们先来看一道例题（选自BUAA_CO_P0） 使用Logisim搭建一个有限状态机检测串行输入字符串中的能匹配正则表达式b{1,2}[ac]{2}的子串并输出。即我们要得到这样一个字符串：开头有一个或两个b，接着要出现两次a/c。 注意：每当匹配到一个子串时，需要输出一次1。例如对字符串bacbacac,模块应当在第1个c输入和第2个c输入时输出1,而在其他时刻保持输出为0。 Moore Machine我们先通过Moore状态机来实现题目要求。Moore状态机是有限状态机的一种，其输出仅依赖于当前状态。即只要系统处于某个特定状态，无论当前输入是什么，都会有对应的输出。 首先我们先画出状态转移图 根据上图我们可以轻松地在logisim中搭出相应的电路 利用真值表构建状态转移模块 Mealy Machine再利用Mealy状态机实现题目要求。Mealy状态机是有限状态机的另外一种，其输出结果不仅和当前状态有关，还和当前输出有关。 我们仍然是先画出状态转移图 在logisim中搭建相应电路 利用真值表构建状态转移模块 由于Mealy状态机的输出Z由状态和输出共同决定，所以可以在构建真值表时直接根据状态和输入给出Z的值。 Moore &amp; Mealy下面我们通过波形图的方式分析两种有限状态机的差别。 上升沿输入一个字符，且输入在一个周期内保持不变 Moore状态机在读入字符c后状态变为11，经过判断符合置位条件，输入变为1，非常符合我们的直觉。 Mealy状态机则在读入字符a后输入就变为1，因为读入a之后状态变为10，此时输入仍为a，状态机识别到字符序列baa，符合置位条件，输入变为1，而在读入c之后状态变为00，不再符合置位条件。 下降沿输入一个字符，且输入在一个周期内保持不变 虽然是下降沿读入一个字符，但是状态机的状态在上升沿时才会更新，所以对于Moore状态机，其实就等于上一种情况滞后一个周期。 对于Mealy状态机，在状态更新为10后，输入仍为a，检测序列为baa，符合置位条件，在之后的下降沿输入变为c，此时检测序列为bac，仍符合置位条件。 异步输入 在接收到字符a后的一个周期内任意时刻输入c，Mealy状态机的输出都会立刻发生变化，而Moore状态机则需要等到下一个时钟上沿到来输出才会变化。 总结 对于本题来说，Moore状态机和Mealy状态机实现的功能有所差异。 Moore状态机同步输出，Mealy状态机异步输出。Mealy对输入的反应更快。 实现相同功能，Mealy所需要的状态数比Moore型少，Moore需要状态稳定才能输出。（对于异步输入来说，因为同步输入时结果并不相同） 并非所有时许电路都可以用Mealy状态机实现，一些时序逻辑电路只能通过Moore状态机实现。","link":"/2024/10/05/Logisim%E8%A7%86%E8%A7%92%E4%B8%8B%E7%9A%84Moore%E4%B8%8EMealy%E7%8A%B6%E6%80%81%E6%9C%BA%E8%BE%A8%E6%9E%90/"},{"title":"C语言程序设计期末总结","text":"常用知识点总结 目录 目录 常见库函数 switch用法 fgets用法 strstr用法 strcmp用法 判断字母大小写 sscan &amp; sprintf用法 取两个数中较大值或较小值 qsort用法 判断一个十进制数的二进制表示中有几个“ 1 ” 找最大公约数 二分法查找数组中目标数值的位置 位运算 1. 按位与（AND）：&amp; 2. 按位或（OR）：| 3. 按位异或（XOR）：^ 4. 按位取反（NOT）：~ 5. 左移：&lt;&lt; 6. 右移：&gt;&gt; 占位符 数据类型及范围 整型数据类型 浮点型数据类型 字符型数据类型 指针类型 数组类型 其他类型 转义符 递归函数计算阶乘 判断质数 冒泡排序 升序 降序 大小写转换函数(toupper &amp; tolower) 常见库函数 字符处理函数（在 &lt;ctype.h&gt; 头文件中） isalpha(int ch)： 检查字符是否是字母。 isdigit(int ch)： 检查字符是否是数字。 isalnum(int ch)： 检查字符是否是字母或数字。 islower(int ch)： 检查字符是否是小写字母。 isupper(int ch)： 检查字符是否是大写字母。 tolower(int ch)： 将字符转换为小写形式。 toupper(int ch)： 将字符转换为大写形式。 字符串处理函数（在 &lt;string.h&gt; 头文件中） strlen(const char *str)： 返回字符串的长度。 strcpy(char *dest, const char *src)： 将一个字符串复制到另一个字符串。 strcat(char *dest, const char *src)： 将一个字符串追加到另一个字符串。 strcmp(const char *str1, const char *str2)： 比较两个字符串。 strncmp(const char *str1, const char *str2, size_t n)： 比较两个字符串的前 n 个字符。 strchr(const char *str, int ch)： 在字符串中查找字符第一次出现的位置。 strstr(const char *haystack, const char *needle)： 在字符串中查找子字符串的第一次出现位置。 数学函数（在 &lt;math.h&gt; 头文件中） sqrt(double x)： 返回 x 的平方根。 pow(double x, double y)： 返回 x 的 y 次幂。 fabs(double x)： 返回 x 的绝对值。 ceil(double x)： 返回不小于 x 的最小整数值。 floor(double x)： 返回不大于 x 的最大整数值。 sin(double x)： 返回 x 的正弦值。 cos(double x)： 返回 x 的余弦值。 tan(double x)： 返回 x 的正切值。 输入/输出函数（在 &lt;stdio.h&gt; 头文件中） printf(const char *format, ...)： 格式化输出到标准输出。 scanf(const char *format, ...)： 格式化输入从标准输入。 fgets(char *str, int n, FILE *stream)： 从文件流中读取一行。 fputs(const char *str, FILE *stream)： 将字符串写入文件流。 fscanf(FILE *stream, const char *format, ...)： 从文件流中格式化输入。 fprintf(FILE *stream, const char *format, ...)： 将格式化输出写入文件流。 内存分配函数（在 &lt;stdlib.h&gt; 头文件中） qsort(void *base, size_t nmemb, size_t size, int (*compar)(const void *, const void *))： 对数组进行快速排序。 malloc(size_t size)： 分配指定字节数的内存。 calloc(size_t num, size_t size)： 分配指定数量和大小的内存块，并将其初始化为零。 realloc(void *ptr, size_t size)： 更改之前分配的内存块的大小。 free(void *ptr)： 释放之前分配的内存块。 这只是一小部分标准库函数。C 语言标准库提供了许多其他有用的函数，用于处理日期和时间、动态分配内存等。标准库函数的完整列表和详细信息可以在相关的 C 语言标准文档中找到。 switch用法1234567891011switch(m){ case 1: case 3: case 5: printf(&quot;yes&quot;); break; case 4:case 6: printf(&quot;no&quot;); break; default: break;} 输入数值后输入字符串 12scanf(&quot;%d\\n&quot;,&amp;n);gets(text); fgets用法 结束使用NULL而非EOF(当 fgets 遇到文件结束时，它会返回一个空指针 (NULL)) strcspn 函数返回字符串中不包含指定字符集合中任何字符的第一个位置（即字符串中不包含这些字符的部分的长度） 用scanf读取字符串时，%s在遇到空格、制表符或换行符时会停止读取。如果用户输入包含空格，只会读取第一个单词1234567fgets(myString, sizeof(myString), stdin);// 去除末尾的换行符myString[strcspn(myString, &quot;\\n&quot;)] = '\\0';// 输出处理后的字符串printf(&quot;Processed string: %s\\n&quot;, myString); strstr用法需要注意的是，strstr 是区分大小写的。如果你需要进行大小写不敏感的查找，可以考虑使用其他函数，比如 strcasestr（不是标准C函数，但在一些系统中可能提供）或手动转换字符串为小写/大写后再使用 strstr。 123456789101112131415161718#include &lt;stdio.h&gt;#include &lt;string.h&gt;int main() { const char *haystack = &quot;Hello, World!&quot;; const char *needle = &quot;World&quot;; // 在 haystack 中查找 needle char *result = strstr(haystack, needle); if (result != NULL) { printf(&quot;'%s' found at position %ld in '%s'\\n&quot;, needle, result - haystack, haystack); } else { printf(&quot;'%s' not found in '%s'\\n&quot;, needle, haystack); } return 0;} strcmp用法12345678910111213141516171819#include &lt;stdio.h&gt;#include &lt;string.h&gt;int main() { const char *str1 = &quot;apple&quot;; const char *str2 = &quot;banana&quot;; int result = strcmp(str1, str2); if (result &lt; 0) { printf(&quot;%s is less than %s\\n&quot;, str1, str2); } else if (result == 0) { printf(&quot;%s is equal to %s\\n&quot;, str1, str2); } else { printf(&quot;%s is greater than %s\\n&quot;, str1, str2); } return 0;} 判断字母大小写1234567891011121314#include &lt;stdio.h&gt;#include &lt;ctype.h&gt;int main() { char ch = 'A'; if (isupper(ch)) { printf(&quot;%c is an uppercase letter.\\n&quot;, ch); } else { printf(&quot;%c is not an uppercase letter.\\n&quot;, ch); } return 0;} 1234567891011121314#include &lt;stdio.h&gt;#include &lt;ctype.h&gt;int main() { char ch = 'a'; if (islower(ch)) { printf(&quot;%c is a lowercase letter.\\n&quot;, ch); } else { printf(&quot;%c is not a lowercase letter.\\n&quot;, ch); } return 0;} sscan &amp; sprintf用法sscanf：用于从字符串中按照指定的格式读取数据。 函数原型：int sscanf(const char *str, const char *format, ...);参数： str：要读取的字符串。 format：格式说明符，指定了要读取的数据的类型和格式。 后续的参数：指向变量的指针，用于存储读取到的数据。 返回值：成功读取并赋值的参数个数。123456789101112131415161718192021#include &lt;stdio.h&gt;int main() { char input[] = &quot;John 25 1.75&quot;; char name[20]; int age; float height; // 从字符串 input 中按照格式读取数据 int result = sscanf(input, &quot;%s %d %f&quot;, name, &amp;age, &amp;height); if (result == 3) { printf(&quot;Name: %s\\n&quot;, name); printf(&quot;Age: %d\\n&quot;, age); printf(&quot;Height: %.2f\\n&quot;, height); } else { printf(&quot;Failed to read data from the string.\\n&quot;); } return 0;} sprintf：用于按照指定的格式将数据写入字符串。 函数原型：int sprintf(char *str, const char *format, ...); 参数： str：目标字符串，用于存储格式化后的数据。 format：格式说明符，指定了要写入的数据的类型和格式。 后续的参数：要写入的数据。 返回值：写入到字符串中的字符数（不包括终止符 \\0）。12345678910111213141516171819#include &lt;stdio.h&gt;int main() { char buffer[50]; int num = 42; float pi = 3.14159; // 将格式化的数据写入字符串 buffer int result = sprintf(buffer, &quot;The number is %d and the value of pi is %.2f&quot;, num, pi); if (result &gt; 0) { // 输出写入的字符串 printf(&quot;Formatted string: %s\\n&quot;, buffer); } else { printf(&quot;Error in sprintf function.\\n&quot;); } return 0;} 取两个数中较大值或较小值12#define MAX(a, b) ((a) &gt; (b) ? (a) : (b))#define MIN(a, b) ((a) &lt; (b) ? (a) : (b)) qsort用法这个函数接受四个参数： base：指向待排序数组的指针。 nmemb：数组中元素的个数。 size：每个元素的大小（以字节为单位）。 compar：比较函数的指针，用于定义元素之间的比较规则。 比较函数 compar 应该返回一个整数： 如果第一个参数小于第二个参数，返回负数。 如果第一个参数等于第二个参数，返回零。 如果第一个参数大于第二个参数，返回正数。123456789101112131415161718192021222324#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;// 比较函数，用于指定整数的比较规则int compareIntegers(const void *a, const void *b) { return (*(int *)a - *(int *)b);//交换a和b实现降序排列}int main() { int numbers[] = {5, 2, 9, 1, 5, 6}; size_t size = sizeof(numbers) / sizeof(numbers[0]); // 使用 qsort 对整数数组进行排序 qsort(numbers, size, sizeof(numbers[0]), compareIntegers); // 输出排序后的数组 for (size_t i = 0; i &lt; size; ++i) { printf(&quot;%d &quot;, numbers[i]); } printf(&quot;\\n&quot;); return 0;} 判断一个十进制数的二进制表示中有几个“ 1 ”12345678910111213int countOnesInBinary(int num) { int count = 0; // 遍历二进制表示中的每一位 while (num != 0) { if (num % 2 == 1) { count++; } num /= 2; } return count;} 找最大公约数12345678int findGCD(int a, int b) { while (b != 0) { int temp = b; b = a % b; a = temp; } return a;} 二分法查找数组中目标数值的位置123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;stdio.h&gt;// 函数声明int binarySearch(int arr[], int low, int high, int target);int main() { int size; // 从用户输入获取数组大小 printf(&quot;Enter the size of the sorted array: &quot;); scanf(&quot;%d&quot;, &amp;size); int arr[size]; // 从用户输入获取已排序的数组 printf(&quot;Enter the sorted array elements:\\n&quot;); for (int i = 0; i &lt; size; i++) { scanf(&quot;%d&quot;, &amp;arr[i]); } int target; // 从用户输入获取要查找的目标值 printf(&quot;Enter the target value to search: &quot;); scanf(&quot;%d&quot;, &amp;target); // 调用二分查找函数 int result = binarySearch(arr, 0, size - 1, target); // 输出查找结果 if (result != -1) { printf(&quot;Target value %d found at index %d.\\n&quot;, target, result); } else { printf(&quot;Target value %d not found in the array.\\n&quot;, target); } return 0;}// 二分查找函数定义int binarySearch(int arr[], int low, int high, int target) { while (low &lt;= high) { int mid = low + (high - low) / 2; // 检查中间元素是否是目标值 if (arr[mid] == target) { return mid; } // 如果目标值在左半部分，则更新 high if (arr[mid] &gt; target) { high = mid - 1; } // 如果目标值在右半部分，则更新 low else { low = mid + 1; } } // 如果目标值不在数组中，返回 -1 return -1;} 位运算1. 按位与（AND）：&amp; 将两个操作数的对应位进行与操作，结果位为1当且仅当两个操作数对应位都为1。 2. 按位或（OR）：| 将两个操作数的对应位进行或操作，结果位为1当且仅当两个操作数对应位至少有一个为1。 3. 按位异或（XOR）：^ 将两个操作数的对应位进行异或操作，结果位为1当且仅当两个操作数对应位不相等。 4. 按位取反（NOT）：~ 对操作数的每个位取反，即将0变为1，将1变为0。 5. 左移：&lt;&lt; 将操作数的所有位向左移动指定的位数，右侧补零。 6. 右移：&gt;&gt; 将操作数的所有位向右移动指定的位数，左侧补符号位（对于有符号整数）或者补零（对于无符号整数）。 占位符123456789101112131415161718192021#include &lt;stdio.h&gt;int main() { int integerVar = 42; float floatVar = 3.14; char charVar = 'A'; char stringVar[] = &quot;Hello, World!&quot;; int *pointerVar = &amp;integerVar; // 使用占位符输出变量的值 printf(&quot;Integer: %d\\n&quot;, integerVar); printf(&quot;Float: %f\\n&quot;, floatVar); printf(&quot;Char: %c\\n&quot;, charVar); printf(&quot;String: %s\\n&quot;, stringVar); printf(&quot;Pointer: %p\\n&quot;, pointerVar); // 使用 %x 输出整数的十六进制形式 printf(&quot;Integer in Hexadecimal: %x\\n&quot;, integerVar); return 0;} 数据类型及范围整型数据类型 int： 整数类型，通常占用4个字节，表示整数值。范围约为 -2,147,483,648 到 2,147,483,647。 char： 字符类型，占用1个字节，表示单个字符的ASCII码值。范围为 0 到 255 或 -128 到 127（有符号/无符号）。 short： 短整数类型，通常占用2个字节，表示较小范围的整数值。范围约为 -32,768 到 32,767。 long： 长整数类型，占用4或8个字节，表示较大范围的整数值。范围约为 -2,147,483,648 到 2,147,483,647（32位系统）或 -9,223,372,036,854,775,808 到 9,223,372,036,854,775,807（64位系统）。 long long： 更长的整数类型，占用8个字节，表示更大范围的整数值。范围约为 -9,223,372,036,854,775,808 到 9,223,372,036,854,775,807。 浮点型数据类型 float： 单精度浮点数类型，通常占用4个字节，表示小数值。范围约为 1.17549435e-38 到 3.40282347e+38。 double： 双精度浮点数类型，通常占用8个字节，表示更高精度的小数值。范围约为 2.2250738585072014e-308 到 1.7976931348623158e+308。 字符型数据类型 char： 字符类型，占用1个字节，表示单个字符的ASCII码值。范围为 0 到 255 或 -128 到 127（有符号/无符号）。 指针类型 int*： 指向整数的指针类型。 float*： 指向浮点数的指针类型。 char*： 指向字符的指针类型。 数组类型 int[]： 整数数组类型。 float[]： 浮点数数组类型。 char[]： 字符数组类型。 其他类型 void： 表示没有数据类型。 enum： 枚举类型，用于定义一组命名的整数常量。 这些数据类型和范围的信息对于正确使用和存储数据至关重要。请注意，数据范围可能会因编译器和操作系统的不同而有所不同。 转义符在C语言中，转义符（Escape Characters）以反斜杠（\\）开头，用于在字符串常量中表示一些特殊字符或控制字符。以下是一些常见的C语言转义符： \\\\n： 换行符（New Line） 示例：printf(&quot;Hello\\\\nWorld&quot;); \\\\t： 水平制表符（Tab） 示例：printf(&quot;Name:\\\\tJohn&quot;); \\\\r： 回车符（Carriage Return） 示例：printf(&quot;One\\\\rTwo&quot;); \\\\b： 退格符（Backspace） 示例：printf(&quot;Back\\\\bSpace&quot;); \\\\f： 换页符（Form Feed） 示例：printf(&quot;Page 1\\\\fPage 2&quot;); \\\\\\\\： 反斜杠自身 示例：printf(&quot;This is a backslash: \\\\\\\\\\\\&quot;); \\\\\\&quot;： 双引号自身 示例：printf(&quot;He said, \\\\&quot;Hello!\\\\&quot;&quot;); \\\\\\'： 单引号自身 \\\\0： 空字符（Null） 示例：字符串结尾的空字符 '\\\\0' 是C语言字符串的终止符。 \\0 到 \\7：八进制转义字符 示例：printf(&quot;Octal representation: \\\\115&quot;);（表示 'M'） \\x0 到 \\xFF： 十六进制转义字符 示例：printf(&quot;Hex representation: \\\\x4A&quot;);（表示 'J'） 递归函数计算阶乘123456789101112131415161718192021222324#include &lt;stdio.h&gt;// 递归函数计算阶乘unsigned long long factorial(int n) { // 基本情况：当 n 为 0 或 1 时，阶乘为 1 if (n == 0 || n == 1) { return 1; } else { // 递归情况：n 的阶乘等于 n 乘以 (n-1) 的阶乘 return n * factorial(n - 1); }}int main() { int num = 5; // 调用递归函数计算阶乘 unsigned long long result = factorial(num); // 输出结果 printf(&quot;Factorial of %d = %llu\\n&quot;, num, result); return 0;} 判断质数123456789101112131415161718192021222324252627282930313233#include &lt;stdio.h&gt;// 判断一个数是否为质数int isPrime(int number) { if (number &lt;= 1) { return 0; // 1和负数不是质数 } for (int i = 2; i * i &lt;= number; ++i) { if (number % i == 0) { return 0; // 能被整除，不是质数 } } return 1; // 不能被整除，是质数}int main() { int num; // 从用户输入获取一个整数 printf(&quot;Enter a positive integer: &quot;); scanf(&quot;%d&quot;, &amp;num); // 调用函数判断是否为质数并输出结果 if (isPrime(num)) { printf(&quot;%d is a prime number.\\n&quot;, num); } else { printf(&quot;%d is not a prime number.\\n&quot;, num); } return 0;} 冒泡排序升序1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;stdio.h&gt;// 冒泡排序函数（升序）void bubbleSortAsc(int arr[], int n) { for (int i = 0; i &lt; n - 1; ++i) { for (int j = 0; j &lt; n - i - 1; ++j) { // 如果当前元素大于下一个元素，交换它们 if (arr[j] &gt; arr[j + 1]) { int temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; } } }}// 打印数组元素void printArray(int arr[], int size) { for (int i = 0; i &lt; size; ++i) { printf(&quot;%d &quot;, arr[i]); } printf(&quot;\\n&quot;);}int main() { int arr[] = {64, 34, 25, 12, 22, 11, 90}; int n = sizeof(arr) / sizeof(arr[0]); // 输出排序前的数组 printf(&quot;Unsorted array: &quot;); printArray(arr, n); // 调用冒泡排序函数（升序） bubbleSortAsc(arr, n); // 输出排序后的数组 printf(&quot;Sorted array (ascending): &quot;); printArray(arr, n); return 0;} 降序1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;stdio.h&gt;// 冒泡排序函数（降序）void bubbleSortDesc(int arr[], int n) { for (int i = 0; i &lt; n - 1; ++i) { for (int j = 0; j &lt; n - i - 1; ++j) { // 如果当前元素小于下一个元素，交换它们 if (arr[j] &lt; arr[j + 1]) { int temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; } } }}// 打印数组元素void printArray(int arr[], int size) { for (int i = 0; i &lt; size; ++i) { printf(&quot;%d &quot;, arr[i]); } printf(&quot;\\n&quot;);}int main() { int arr[] = {64, 34, 25, 12, 22, 11, 90}; int n = sizeof(arr) / sizeof(arr[0]); // 输出排序前的数组 printf(&quot;Unsorted array: &quot;); printArray(arr, n); // 调用冒泡排序函数（降序） bubbleSortDesc(arr, n); // 输出排序后的数组 printf(&quot;Sorted array (descending): &quot;); printArray(arr, n); return 0;} 大小写转换函数(toupper &amp; tolower)1234567891011121314#include &lt;stdio.h&gt;#include &lt;ctype.h&gt;int main() { char ch = 'A'; // 使用 tolower 将字符转换为小写形式 char lowercaseCh = tolower(ch); printf(&quot;Original character: %c\\n&quot;, ch); printf(&quot;Lowercase character: %c\\n&quot;, lowercaseCh); return 0;}","link":"/2024/07/31/final_summary/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2024/07/30/hello-world/"},{"title":"大模型调研——以《链接》第六链为例","text":"科研课题调研任务 声明 为了公平起见，本次所比较的四个大模型均使用免费的默认模型（打开对应的网页直接使用）。 所引用的回答均是首次回答。 所有排行均是个人主观判断 一、我对第六链的理解在第五链中，作者着重介绍了“枢纽节点”，提出了对“随即网络”的质疑，并指出“枢纽节点服从严格的数学规律，枢纽节点的无处不在促使我们对网络进行全新的思考”。 在第六链中，作者向我们介绍了复杂网络的分布规律——幂律。我认为对第六链的总结应包含以下几个方面： 帕累托定律（80/20定律）与幂律的关系。幂律从数学角度验证了80/20定律：少数几个大事件发挥了大部分的作用。 幂律分布与钟形分布与无尺度网络。钟形分布曲线有一个峰，这个峰代表所有节点的特征尺度，偏离这一尺度的事件很少发生；，幂律分布曲线没有峰，而是不断递减的曲线，在幂律分布中，大量微小事件和少数非常重大的事件并存，无法找到一个能代表所有节点特性的节点，即不存在固有的尺度，拥有这一分布特征的网络被称为“无尺度网络”。 幂律分布网络的不均匀性。多数少链接节点和少数多链接节点（枢纽节点）并存，网络的连通性由少数枢纽节点保证，是它们让真实网络免于瓦解。 无序到有序的涌现与自组织。在相变点，物质开始遵循相同的幂律，不同系统之间有着高度的相似。幂律是复杂系统自组织所独有的特性。 幂律无处不在。在各个学科中，只要有自组织的现象，就存在幂律。 二、文本阅读能力epub文件来源于Z-Library，0.99MB pdf文件由epub文件通过zamzar转换而来，5.20MB 两个文件均为整本书 ChatGPT 通义千问 零一万物 腾讯元宝 epub文件阅读 ✗ ✓ ✗ ✗ pdf文件阅读 ✓ ✓ ✓ ✓ 文档大小 可上传20个文件，单个文件上限512MB 可上传100个文件，单个文件上限150MB 支持10个pdf同时上传，总页数上限5000（约500万字） 可上传50个文件，单个文件上限100MB 三、文本摘要能力给出整本书的文件，仅总结第六链epub - 通义千问 第六链讨论了幂律（Power Law）在复杂网络中的分布规律。幂律揭示了网络中节点的连接度分布并非随机，而是遵循一定的数学规律。这种规律体现在许多自然和社会现象中，比如财富分配、城市规模等，并且在网络科学中尤为重要。 书中提到，帕累托（Pareto）和他的80/20定律是幂律的一个著名例子，即少数关键因素往往决定了大部分的结果。在复杂网络中，这意味着少数枢纽节点拥有大量的链接，而大多数节点只有很少的链接。这样的分布可以用概率形式表达，一个随机选择的节点恰好拥有k条链接的概率服从分布P(k)～k^(-γ)，其中γ被称为度指数。 巴拉巴西等人发现，万维网的结构也符合幂律分布，这表明网络具有无尺度特性（scale-free），即网络中存在一些高度连接的节点（枢纽节点）。这些枢纽节点的存在使得网络表现出小世界特性，即任意两个节点之间的平均路径长度相对较短。此外，幂律分布还出现在其他系统中，如好莱坞演员的合作网络。 幂律分布不仅是复杂网络的关键特征之一，也是理解网络健壮性与脆弱性的基础。它表明，虽然大多数节点对网络的整体连通性影响不大，但枢纽节点对于保持网络的完整性和功能性至关重要。如果枢纽节点被移除，整个网络可能会分裂成碎片。因此，幂律分布为我们提供了关于如何设计更加鲁棒的网络以及如何更有效地分析和控制网络的洞见。 通义千问对epub文件的总结很详细，但显然没抓住了本章的重点，且忽略了一部分内容。此外，通义千问还擅自加入了一些额外的内容，如“提供了关于如何设计更加鲁棒的网络以及如何更有效地分析和控制网络的洞见”，这些概念并没有在文件中出现。 pdf - ChatGPT 第六链《幂律——复杂网络的分布规律》讨论了复杂网络中的一个重要特性——幂律分布。幂律规律揭示了在复杂系统中，少数节点会拥有大量连接，而大多数节点则只有少量连接。该规律与帕累托的80/20定律类似，表现为少部分节点掌握了大部分连接。通过幂律分布，我们可以看到有序是如何从无序中涌现出来的，从看似随机的结构中，复杂网络逐渐自组织并展现出稳定的分布模式。 在这一链中，书中通过多个案例讨论了幂律分布的普遍性，包括互联网的连接分布、社交网络的关系模式等，强调了这种分布在现实世界中的无处不在。 ChatGPT的回答很简短，但却最能抓住重点，基本覆盖了本章的所有重要内容。个人认为是最佳回答。 pdf - 通义千问 第六链主要讨论了复杂网络中的幂律分布规律。这一章节揭示了在许多真实世界的网络中，节点的连接度（即一个节点与其他节点相连的数量）并不是均匀分布的，而是遵循一种特定的数学模式——幂律分布。幂律分布意味着少数节点拥有大量的链接，而大多数节点只有很少的链接。这种分布通常用P(k)～k^(-γ)来表示，其中P(k)是具有k个链接的节点的概率，γ是一个大于1的常数，称为度指数。 书中提到，幂律分布在多种系统中都有出现，包括互联网、社交网络、细胞内的分子网络等。例如，在万维网中，少量网页成为了非常受欢迎的中心节点，它们被大量其他网页所链接，而绝大多数网页则相对较少地被链接。这样的结构被称为无尺度网络，它与传统的随机网络模型有很大的不同。 此外，本章还探讨了幂律分布如何从无序中涌现有序，并且解释了生长机制和偏好连接是形成这种分布的两个重要原则。这意味着网络中的新节点更倾向于与那些已经拥有许多链接的节点建立联系，从而加强了这些中心节点的重要性，导致“富者愈富”的现象。这一过程也体现了“适者愈富”或“胜者通吃”的动态，其中某些节点能够迅速成长为网络中的关键枢纽。 通义千问对pdf的总结不如epub，把重点放在了介绍“什么是幂律分布”，忽略了一部分内容，不像是对文章的总结。且出现了和对epub总结一样的问题，额外联想了一些内容，在最后一段中出现了大量下一章的内容，这显然不是我们在文章总结中所希望看到的。 pdf - 零一万物 第六链主要讨论了复杂网络中的分布规律，特别是幂律分布。这一概念起源于帕累托提出的80/20定律，即在许多情况下，约80%的效果是由约20%的原因产生的。在网络科学中，幂律分布表明网络中的节点连接度分布是不均匀的，少数节点（即枢纽节点）拥有大量的连接，而大多数节点的连接数则相对较少。这种分布方式对于理解网络的结构和行为非常重要，因为它揭示了网络中连接模式的普遍规律，以及这些规律如何影响网络的稳定性和传播动力学。 观点错误，幂律分布并不是起源于80/20定律。且概括不全面，缺少要点。 pdf - 腾讯元宝 第六链主要探讨了复杂网络中的幂律分布现象，解释了幂律在网络中的普遍性和重要性，并提出了无尺度网络模型。以下是主要内容： 幂律分布的普遍性：幂律分布不仅在万维网和好莱坞演员网络中出现，还在许多其他领域（如细胞网络、食物链网络、互联网等）中普遍存在。这种分布揭示了网络中少数枢纽节点的重要性。 无尺度网络模型：巴拉巴西和雷卡·阿尔伯特提出了一个无尺度网络模型，解释了幂律分布的来源。该模型通过“复制-连接”操作生成具有层次化聚团性的网络，展示了无尺度网络和模块化网络的融合。 枢纽节点的作用：枢纽节点在网络中扮演着关键角色，它们连接了大量其他节点，使得网络具有小世界特性。枢纽节点的存在使得网络在面对局部故障时更具健壮性，但也更容易受到攻击。 模块化与无尺度网络的结合：研究表明，许多真实网络不仅是无尺度的，还具有模块化特性。这种结合使得网络在保持整体连通性的同时，也能在局部区域内进行高效的组织和运作。 存在非本章的内容，如“枢纽节点的存在使得网络更容易受到攻击”和“真实网络具有模块化特性”。显然没有很好的分割各个章节。 仅给出第六链部分的pdf文件，总结第六链pdf - ChatGPT - 6’only 你上传的文件提到了关于复杂网络和幂律分布的内容，重点包括以下几个方面： 幂律分布的特点：幂律分布是指很多小事件与少数重大事件共存的现象。该分布在现实中没有峰值，呈现出一种不断递减的曲线。这种现象在许多领域都有应用，例如互联网、社会经济不平等以及自然现象等。 帕累托与80/20定律：帕累托最初发现经济中的不平等现象，用他的经验观察指出80%的财富掌握在20%的人手中。这一原则后来被扩展为管理学中的80/20定律，适用于众多领域，例如客户服务、工作效率等。 无尺度网络与枢纽节点：无尺度网络是指遵循幂律度分布的网络，这种网络的特点是大多数节点连接较少，而少数枢纽节点连接很多。在这种结构中，网络的连通性和稳定性主要依赖于这些枢纽节点。 有序与无序的涌现：通过对物质相变的研究，物理学家发现了从无序到有序的自然转变过程中，幂律往往标志着从混沌到有序的过渡。这种现象不仅仅适用于物理系统，也适用于复杂网络等许多其他领域。 总结来说，幂律和无尺度网络揭示了自然界和社会系统中普遍存在的一种秩序，它们解释了从无序到有序的转变，以及少数事件对整体系统的深远影响。这些规律为理解复杂系统提供了重要的理论基础。 完美！ pdf - 通义千问 - 6‘only 这本书中提到的幂律和无尺度网络是理解复杂系统的关键概念。以下是这些概念的核心要点总结： 幂律分布：这是一种没有峰值且不断递减的分布，它描述了大量微小事件与少数重大事件共存的情况。例如，在一个假设星球上，如果居民身高遵循幂律分布，那么大多数人的身高会非常矮，但也会存在极少数几百米高的巨人。 无尺度网络：这种网络的特点是其节点度数（即链接数量）遵循幂律分布。在这样的网络里，大部分节点只有很少几个链接，而少数枢纽节点拥有大量的链接。无尺度网络的结构类似于航空交通系统，其中许多小机场通过少数主要交通枢纽连接在一起。 帕累托定律（80/20定律）：这个原则表明，一小部分因素通常会产生大部分结果。比如，80%的利润可能来自20%的员工；或者80%的土地被20%的人口所占有。尽管80/20法则有多种应用，但它并不适用于所有情况，而是特定系统中的特征。 幂律在网络中的意义：当研究者发现万维网上的网页链接也遵循幂律时，这揭示了真实网络远非随机，而是具有某种内在秩序。这意味着网络中有重要的组织规则在起作用，特别是那些高度连接的枢纽节点对整个网络的稳定性、动态行为以及健壮性有着决定性的影响。 自组织与涌现现象：书中还探讨了从无序到有序转变的现象，如水结冰或磁体形成的过程。这些相变展示了如何从个体单元间的简单相互作用中涌现出复杂的集体行为，这是理解和分析复杂系统的另一个关键方面。 综上所述，幂律和无尺度网络的概念帮助我们理解了复杂系统背后的规律性和自组织特性，并强调了在看似混沌的环境中存在的潜在秩序。 要点总结完美，但最后的综述偏离了文章主旨。 pdf - 零一万物 - 6’only 本文讨论了复杂网络中的幂律分布，这是一种没有峰值、不断递减的曲线，其中大量微小事件与少数重大事件并存。无尺度网络遵循幂律度分布，其中大多数节点只有少数链接，通过少数高度连接的枢纽节点连接在一起。帕累托的80/20定律是幂律分布的一个例子，其中80%的结果来自20%的原因。 文章提到，40年前，埃尔德什和莱利将复杂网络视为随机系统，但幂律的出现表明这些网络实际上是自组织的。万维网上，网页链接数的分布遵循幂律，度指数接近2。这种分布意味着网络不是随机的，而是存在某种秩序。 文章还讨论了相变，即物质从无序到有序的转变，其中也观察到了幂律。物理学家利奥·卡达诺夫和肯尼斯·威尔逊等人的工作揭示了相变中的普遍性，即不同系统在临界点附近表现出相似的行为，遵循幂律。 最后，文章提出了问题：在网络中观察到的幂律意味着什么类型的转变？为什么枢纽节点出现在各种网络中？是否存在某种根本定律让不同的网络具有相同的普遍形式和形状？这些问题表明，尽管我们已经知道枢纽节点和幂律分布是自组织和有序的标志，但产生这些现象的机制仍然是一个谜。 逻辑混乱，重点不突出，总结性不强。 pdf - 腾讯元宝 - 6‘only 这篇文章探讨了幂律分布及其在复杂网络中的应用，特别是无尺度网络的特征和重要性。 幂律分布的定义与特征： 幂律分布的定义：幂律分布是一种没有峰值且不断递减的曲线，特征是大量微小事件和少数重大事件并存。 幂律分布的实例：例如，星球上居民的身高分布，大多数人都很矮，但偶尔会有几百米高的巨人。 幂律分布与钟形曲线的区别：钟形曲线有明显的峰值，而幂律分布没有峰值，尾部衰减得更慢，允许“罕见事件”的存在。 无尺度网络的概念： 无尺度网络的定义：无尺度网络是遵循幂律度分布的网络，大多数节点只有少数几个链接，通过少数高度连接的枢纽节点连接。 无尺度网络的视觉形象：类似于航空交通系统，很多小机场通过少数几个主要交通枢纽连接。 无尺度网络与随机网络的对比：随机网络大多数节点拥有相同的链接数，而无尺度网络有少数枢纽节点拥有大量链接。 帕累托与80/20定律： 帕累托的生平与背景：意大利经济学家，曾从事铁路工程，后致力于经济学研究。 帕累托的观察与定律：发现80%的财富由20%的人口占有，提出了著名的80/20定律。 80/20定律的应用与扩展：广泛应用于管理学、社会学等领域，描述了大多数情况下，少量因素决定了大部分结果的现象。 幂律分布与度指数： 幂律分布的数学表达：幂律分布可以用幂函数表示，每个幂律都有一个独一无二的幂指数。 万维网的幂律分布：网页链接数的分布遵循幂律，度指数接近2。 其他复杂网络的幂律分布：如好莱坞演员网络、细胞内部网络等，均遵循幂律分布。 幂律网络的特性与影响： 幂律网络的不均匀性：大多数节点只有少数链接，枢纽节点拥有大量链接，保证了网络的连通性。 幂律网络的无尺度特性：没有特征节点，节点间存在连续的层级结构。 枢纽节点的重要性：枢纽节点决定了网络的结构稳定性、动态行为、健壮性、容错性和故障容忍性。 幂律分布的普遍性与自组织： 幂律分布的普遍性：在自然界和复杂系统中广泛存在，如液体结冰、磁体涌现等。 相变与幂律分布：临界点附近，系统从无序到有序的相变过程中，幂律分布起着关键作用。 重整化理论：由肯尼斯·威尔逊提出，解释了幂律分布的数学基础，揭示了从无序到有序的转变机制。 幂律分布的未来研究方向： 枢纽节点生成机制的研究：尚未完全解决，需要进一步探索。 复杂网络的临界点研究：研究网络为何处于临界点并展现无尺度行为。 普遍网络定律的探索：寻找不同网络具有相同普遍形式和形状的根本定律。 总的来说，这篇文章详细介绍了幂律分布及其在复杂网络中的应用，特别是无尺度网络的特征和重要性，展示了幂律分布在不同领域中的普遍性和深远影响。 要点全面，但是冗余信息过多，总结性不强。 小结将整本书上传给大模型并要求总结特定章节时，部分大模型会出现“章节划分不清晰”的问题。而仅上传特定章节让其总结，效果显著提高。 四个大模型均可通过进一步提示扩写摘要，但大致内容没有变化。 在所评测的四个大模型中，ChatGPT &gt; 通义千问 &gt; 腾讯元宝 &gt; 零一万物。 四、文本理解能力仅给出第六链部分的文件，基于我自己提出的问题比较四个大模型的文本理解能力。 Q1：幂律分布和钟形分布的区别ChatGPT 根据你上传的文件，幂律分布和钟形分布之间的主要区别如下： 形状和分布特征： 幂律分布：是一条没有峰值、不断递减的曲线，表示大多数事件非常小，少数事件非常大。幂律分布允许极端事件（如巨大的枢纽节点）存在，通常在复杂网络中广泛出现。 钟形分布（正态分布）：有一个明显的峰值，表示大多数事件集中在平均值附近，偏离平均值的事件相对较少。钟形分布常见于自然界的随机现象，如人的身高、体重等。 尾部衰减： 幂律分布：尾部衰减较慢，意味着极端大事件的发生虽然少见，但仍可能出现。比如，在网络中少数枢纽节点拥有大量连接。 钟形分布：尾部衰减非常快，极端事件几乎不会出现。它表明系统中的大多数事件会集中在某个范围内，极端偏离的现象极为罕见。 应用场景： 幂律分布：适用于复杂系统，如互联网节点、社交网络、科学家之间的引用关系等，反映了大多数节点只有少数连接，而少数枢纽节点连接非常多。 钟形分布：适用于随机现象或系统，如大气分子的速度分布、人类的智商分布等。 总结：幂律分布强调少数重大事件对系统的显著影响，而钟形分布强调事件的集中性和一致性，极端事件在钟形分布中非常少见。 观点正确，回答全面，逻辑性强。 通义千问 幂律分布和钟形分布（也称为正态分布或高斯分布）在形状和特性上有显著的区别： 形状上的区别： 钟形分布：这种分布有一个明显的峰，大多数数据点集中在平均值附近，随着远离平均值，出现的数据点数量迅速减少。它呈现出对称的钟形曲线。 幂律分布：幂律分布没有明显的峰，而是呈现出一条不断递减的曲线。这意味着有大量微小事件的存在，同时伴随着少数非常重大的事件。 尾部行为： 钟形分布：其尾部衰减得非常快，偏离平均值较远的数据点极为罕见。这表明极端事件的发生概率极低。 幂律分布：幂律分布的尾部衰减速度慢得多，允许存在“罕见事件”。例如，在一个假设的星球上，如果居民身高遵循幂律分布，那么虽然大多数人很矮，但偶尔看到一个几百米高的巨人也不会让人感到特别惊讶。 数学表达： 钟形分布：可以用正态分布函数来描述，具有明确的均值和方差。 幂律分布：通常用幂函数来表示，形式为 $N(k) \\sim k^{-\\gamma}$，其中 (k) 是变量，(N(k)) 是该变量取值 (k) 的频率，而 $\\gamma$ 是度指数。不同的系统会有不同的 $\\gamma$ 值。 实际应用中的意义： 钟形分布：适用于很多自然现象，如人类的身高、智商等，这些量通常围绕着某个中心值波动，并且极端值很少见。 幂律分布：则常见于复杂网络中，比如网页链接数、社交网络中的好友数等，说明了网络中存在少量高度连接的节点（枢纽节点），它们对于整个网络结构至关重要。 简而言之，钟形分布强调的是数据的集中趋势，而幂律分布则揭示了数据中存在的广泛差异性和极端事件的可能性。这两种分布反映了自然界和社会现象中不同类型的数据模式。 完美！逻辑和ChatGPT很像，但是多出了数学表达部分。 零一万物 幂律分布和钟形分布的主要区别在于它们在分布尾部的行为。钟形分布，如正态分布，在尾部呈现出指数衰减，这意味着极端事件发生的概率非常低。相比之下，幂律分布在尾部的衰减要慢得多，这允许罕见事件（如枢纽节点）的存在。在钟形分布中，极端事件几乎不可能发生，而在幂律分布中，虽然罕见事件发生的概率也很低，但它们的存在是分布的一个显著特征。 “主要区别在于它们在分布尾部的行为”这一观点并不准确，缺乏逻辑性。 腾讯元宝 根据文档内容，幂律分布和钟形分布在分布的尾部存在重要的定性差异： 尾部衰减速度： 钟形分布：尾部的指数衰减速度非常快。这意味着偏离平均值的节点（如具有极多或极少链接的节点）非常罕见。 幂律分布：尾部的衰减速度较慢。这意味着在幂律分布中，存在一些“罕见事件”，即具有极多链接的枢纽节点。 枢纽节点的存在： 钟形分布：由于尾部快速衰减，枢纽节点几乎不存在。大多数节点的链接数都接近平均值。 幂律分布：由于尾部衰减较慢，枢纽节点可以存在。这些枢纽节点拥有大量链接，使得网络具有高度的连通性。 分布形状： 钟形分布：呈现出一个明显的峰值，表明大多数节点的链接数集中在平均值附近。 幂律分布：没有明显的峰值，呈现不断递减的曲线，表明大多数节点的链接数较少，但存在少数节点拥有非常多的链接。 总结来说，幂律分布和钟形分布的主要区别在于尾部的衰减速度和枢纽节点的存在与否。钟形分布的尾部快速衰减，导致枢纽节点不存在；而幂律分布的尾部衰减较慢，允许枢纽节点的存在。 我个人认为，在幂律分布和钟形分布的差别中不应该出现“枢纽节点”，因为枢纽节点是具有幂律特性的网络中的一个具体现象，而不是两种分布的差异所在。 对于Q1，通义千问 &gt; ChatGPT &gt; 腾讯元宝 &gt; 零一万物 Q2：什么是度指数ChatGPT 根据文件，度指数是用于描述复杂网络中节点的链接数（度数）分布的一种参数，通常与幂律分布相关。 具体来说，度指数是幂律分布公式中的指数参数，用来衡量网络中节点的链接数是如何分布的。例如，对于一个网络，具有 ( k ) 个链接的节点数 ( N(k) ) 遵循幂律分布，表达式为：$ N(k) \\sim k^{-\\gamma} $其中，γ（度指数） 描述了链接数分布的衰减速率。度指数越小，表示网络中有更多节点拥有大量链接；度指数越大，表示大部分节点的链接数较少，而少数枢纽节点拥有非常多的链接。 在万维网的研究中，导入链接数的分布度指数大约为 2，而导出链接的分布度指数略大一些，表明不同网页之间的链接并不均匀，大多数网页有少量链接，而少数网页有大量链接。 用词准确，回答简介易懂，没有缺少要点。 通义千问 度指数是幂律分布中的一个关键参数，它描述了网络中节点的链接数（即度）是如何分布的。在数学上，如果一个网络的节点度数遵循幂律分布，那么可以表示为 $N(k) \\sim k^{-\\gamma}$，这里的 (k) 表示节点的度数，(N(k)) 表示具有 (k) 个链接的节点数量，而 $ \\gamma $ 就是度指数。 度指数 $ \\gamma $ 的值决定了网络中不同度数节点的数量比例。具体来说： 当 $ \\gamma $接近2时，意味着非常流行的节点（拥有大量链接的节点）相对较多。 如果 $ \\gamma $ 稍微大一些，比如接近3或更大，则说明非常流行的节点较少，大多数节点只有少量链接。 通过度指数，我们可以了解相对于不流行的网页，到底有多少非常流行的网页。在网络分析中，度指数通常用来衡量网络的异质性，以及识别出那些对网络连通性和稳定性起着关键作用的高度连接节点（枢纽节点）。例如，在万维网的研究中发现，网页的导入链接数和导出链接数都遵循幂律分布，其中导入链接的度指数接近2，而导出链接的度指数则稍微大一些。这些发现表明，尽管大部分网页只有少量链接，但少数网页却拥有大量的链接，这构成了无尺度网络的特征。 基本和ChatGPT打平，用词稍微有点冗余，不够简洁，但无伤大雅。 零一万物 度指数是指在网络中，节点连接度的分布遵循幂律分布时的幂指数。它表征了网络中节点连接度分布的形状，即有多少节点拥有多少连接。度指数可以通过在双对数坐标系下拟合节点连接度的直方图来确定，直线的斜率即为度指数。在万维网上，度指数接近2，这意味着网页的导入链接数的分布遵循幂律，且大多数网页只有少数链接，而少数枢纽网页则拥有非常多的链接。 观点有误，度指数并非代表有多少节点拥有多少连接，缺少要点，缺少数学公式。 腾讯元宝 根据文档内容，度指数是指幂律分布中的一个参数，用来描述网络中度（即节点的连接数）的分布情况。具体来说，度指数决定了幂律分布的具体形式。在网络科学中，度指数通常表示为γ，用来描述节点连接数的分布。文档中提到： 每一个幂律都有一个独一无二的幂指数。通过幂指数我们可以得知，相对于那些不流行的网页，到底有多少非常流行的网页。在网络中，幂律可用于描述度的分布，而幂指数通常被称为度指数。 例如，文档中提到网页的导入链接数的分布遵循幂律，度指数接近2；导出链接的度指数稍微大一些，大约为2.5。这意味着，如果有k个导入链接的网页数目N(k)遵循幂律分布，则可以表示为： $ N(k) \\sim k^{-\\gamma} $ 其中，γ就是度指数。在文档中提到的具体数值中，导入链接的度指数γ接近2，导出链接的度指数γ约为2.5。 回答没有问题，但引用显得有些多余，逻辑也不够清晰。 对于Q2，ChatGPT = 通义千问 &gt; 腾讯元宝 &gt; 零一万物 Q3：互联网中的幂律是如何被发现的ChatGPT 根据文件，互联网中的幂律分布是通过对万维网结构的分析而被发现的。发现过程如下： 最初的预期：研究者最初预计万维网是一个随机网络，网页之间的链接数应遵循类似于钟形曲线的单峰分布。这意味着大多数网页的链接数相差不大，且没有明显的极端现象。 实际发现：当郑浩雄（研究者）设计万维网采集机器人来分析网络时，采集到的数据表明，万维网上的链接数分布并不符合钟形分布。相反，很多网页只有少量链接，而少数网页拥有大量链接（枢纽节点）。这种分布与预期大相径庭。 幂律分布的确认：通过将网络节点的链接数进行双对数坐标图绘制，研究者发现节点的连接度分布遵循幂律分布。这意味着，网页的链接数按照幂律的方式衰减：大多数节点只有少量链接，但少数枢纽节点拥有非常多的链接。 结果的意义：这一发现表明，万维网并不是一个随机网络，而是一个无尺度网络（幂律分布的网络），其中少数枢纽节点在网络的连通性和结构中扮演着重要角色。研究者进一步观察到，其他复杂网络（如好莱坞演员网络、科学家引用网络等）也呈现出类似的幂律分布。 通过这一过程，研究者首次确认了万维网的链接数遵循幂律分布，从而揭示了互联网背后复杂的网络结构。 要点没有缺失，逻辑清晰，标准答案！ 通义千问 互联网中的幂律是通过研究网页之间的链接结构而被发现的。具体来说，当科学家们开始使用网络爬虫（微型搜索引擎）来探索万维网的结构时，他们原本预期会看到类似于随机网络的单峰分布，即大多数网页具有相似数量的链接。然而，实际观察到的结果却与这一预期大相径庭。 研究人员注意到，在万维网中： 许多节点（网页）只有少量链接。 一些枢纽节点（少数非常流行的网页）拥有大量的链接。 这种模式在双对数坐标系下进行拟合时，显示出一个令人惊讶的现象：网页链接数的分布严格遵循被称为幂律的数学表达式。这意味着，对于具有 (k) 个导入链接的网页数目 (N(k))，其分布可以用公式 $ N(k) \\sim k^{-\\gamma} $ 来描述，其中 $\\gamma$ 是度指数，大约为2.1；而对于导出链接数的分布，度指数则稍大一些，约为2.5。 这些发现表明，万维网并不是一个随机网络，而是展现出了一种全新的秩序——无尺度网络。在这个网络中，大部分节点仅有少数几个链接，但少数高度连接的枢纽节点确保了整个网络的连通性。这样的网络结构具有不同寻常的一致性和美感，并且揭示了复杂网络背后的自组织特性。此外，它也预示着存在一些重要的规则支配着网络的演化过程。这个发现改变了人们对网络结构的理解，并推动了进一步的研究，以探究其他复杂系统如好莱坞演员网络、科学合作网络等是否也遵循类似的规律。 要点完整，但是逻辑不够清晰，介绍“幂律”有点多余。 零一万物 互联网中的幂律是通过对万维网上网页链接的分布进行研究而被发现的。研究人员设计了微型搜索引擎（也称为网络爬虫或机器人），用来收集和分析网页之间的链接。他们发现，网页的导入链接数遵循幂律分布，度指数接近2。这意味着网页链接的分布并不是随机的，而是呈现出一种特定的模式，其中大多数网页只有少量链接，而少数网页（枢纽节点）则拥有非常多的链接。这种分布与传统的钟形曲线不同，它表明了网络的自组织特性，即网络不是随机生成的，而是由某种规则支配的。 要点完整，逻辑清晰，但是不够详细，语言描述上有待加强。 腾讯元宝 根据文档内容，互联网中的幂律是通过以下步骤和实验被发现的： 初步观察：郑浩雄在设计万维网采集机器人时，原本预期网页之间的连接是随机的，类似于单峰分布，即大多数文档的流行度相似。 实际数据采集：机器人带回的网络数据中，发现许多节点只有少量链接，而一些枢纽节点却拥有非常多的链接。 数据分析：在双对数坐标系下拟合节点连接度的直方图时，发现网页链接数的分布严格遵循幂律的数学表达式。 幂律特征：幂律分布没有峰，是一条不断递减的曲线，这意味着大量微小事件和少数非常重大的事件并存。这与自然界中大多数量遵循的钟形曲线（单峰分布）有显著差异。 广泛适用性：除了万维网，幂律分布也在其他复杂网络中被发现，如好莱坞演员网络、细胞内部网络、物理期刊引用网络等。这些发现表明，幂律分布是一种普遍存在于复杂网络中的现象。 科学研究：科学家们进一步研究了幂律分布的数学特性和物理意义，发现幂律分布通常标志着从无序到有序的过渡，是复杂系统自组织的一种表现。 理论发展：为了理解幂律分布背后的机制，物理学家提出了重整化群理论，由肯尼斯·威尔逊等人发展，为相变和临界现象提供了统一的解释框架。 通过这些步骤，科学家们逐渐认识到幂律分布是描述复杂网络，特别是互联网中节点连接度分布的关键数学工具。 存在大量冗余信息，逻辑混乱。 对于Q3，ChatGPT &gt; 零一万物 &gt; 通义千问 &gt; 腾讯元宝 Q4：具有幂律度分布的网络为什么被称为“无尺度网络”ChatGPT 根据文件，具有幂律度分布的网络之所以被称为“无尺度网络”，是因为在这些网络中没有一个特定的特征节点或特征尺度 来描述整个网络的结构。 具体来说： 度分布没有特征尺度：在无尺度网络中，节点的连接数（度数）并不集中在一个特定的值范围内。相反，连接数分布遵循幂律，大多数节点拥有少量链接，而少数枢纽节点拥有大量链接。这种分布没有峰值或明显的平均值，因此无法用单一的度数来概括所有节点。 层级结构：无尺度网络展现出一种连续的层级结构，从少数具有大量链接的枢纽节点到大量只有少量链接的小节点。由于没有统一的尺度或平均链接数，网络的整体结构是通过这种层级组织维持的，而不是通过均匀分布的节点。 幂律分布的性质：幂律分布的尾部衰减较慢，允许极少数节点拥有非常多的链接（即枢纽节点），这与随机网络中大多数节点拥有相似链接数的情况不同。无尺度网络的连通性和稳定性主要依赖这些枢纽节点，而随机网络的节点连接度具有特定的尺度（通常为平均连接数）。 因此，具有幂律度分布的网络被称为“无尺度网络”，因为它们没有固定的特征节点或平均连接数，表现出一种从大量小节点到少数枢纽节点的层级结构。 要点完整，详略得当，标准答案！ 通义千问 具有幂律度分布的网络被称为“无尺度网络”，主要是因为这种网络中不存在一个典型的或者特征性的节点度数（即链接数量）。在传统的随机网络中，节点的度分布呈现出单峰曲线，大多数节点拥有接近平均值的链接数，偏离这个平均值的情况非常少见。这样的网络有一个明确的特征尺度，可以用平均节点来代表。 相比之下，在遵循幂律度分布的网络里，绝大多数节点仅有少数几个链接，而同时存在少量高度连接的枢纽节点，每个枢纽节点拥有大量的链接。由于这些枢纽节点的存在，网络中的节点度数范围可以从很小延伸到非常大，形成了一个连续的层级结构，从极少数的大枢纽节点到众多的小节点。因此，在这种网络中，无法找到一个能够代表所有节点特性的单一尺度或特征节点。 具体来说： 没有特征尺度：幂律分布缺乏钟形曲线那样的峰值，这表明在网络中找不到一个可以作为“典型”或“平均”的节点。 连续的层级结构：从最大的枢纽节点开始，随后是稍微小一些的枢纽节点，接着是一系列更小的节点，最后是大量的小节点，形成了一个平滑过渡的层级结构。 网络连通性依赖于枢纽节点：小节点拥有的少数链接不足以保证整个网络完全连通，而是由少数高度连接的枢纽节点确保了网络的整体连通性。 由于上述特性，研究者将这类网络称为“无尺度网络”，强调了它们与传统随机网络在结构上的根本不同。无尺度网络的概念揭示了自然界和人类社会中许多复杂系统的共通规律，并且对理解这些系统的稳定性、动态行为以及故障容忍性等方面提供了重要的视角。 和ChatGPT的逻辑很相似，但是语言描述上不够简洁。 零一万物 具有幂律度分布的网络被称为“无尺度网络”是因为在这种网络中，节点的连接度分布遵循幂律，这意味着网络中不存在特征尺度。在无尺度网络中，大多数节点只有少数连接，而少数枢纽节点拥有大量连接。这种分布没有峰值，衰减速度比钟形分布慢，允许罕见但高度连接的枢纽节点存在。由于没有特征尺度，网络的结构和动态行为不能通过单一的尺度来描述，因此被命名为“无尺度网络”。 要点不够清晰，逻辑混乱。 腾讯元宝 根据文档内容，具有幂律度分布的网络被称为“无尺度网络”的原因如下： 幂律分布的特性：幂律分布是一种没有峰值的分布，其特点是大量微小事件和少数非常重大的事件并存。这与钟形分布（如正态分布）不同，后者有一个明显的峰值，表明大多数事件集中在平均值附近。 网络结构的特殊性：在无尺度网络中，大多数节点只有少数几个链接，而少数枢纽节点拥有非常多的链接。这种结构使得网络在形状上类似于航空交通系统，其中很多小机场通过少数几个主要的交通枢纽连接在一起。 无尺度特性：幂律分布的无尺度特性意味着网络中没有特征尺度或特征节点。在随机网络中，分布的峰值意味着绝大多数节点拥有同样数目的链接，而在无尺度网络中，幂律分布没有峰值，表明节点间存在连续的层级结构，从少数枢纽节点到为数众多的小节点。 枢纽节点的决定性作用：无尺度网络中的枢纽节点对网络的连通性和整体结构起着决定性作用。这些枢纽节点的存在使得网络免于瓦解，并且它们的数量和分布遵循幂律分布。 放弃尺度或特征节点的概念：由于幂律分布没有峰值，网络中不存在固有的尺度或特征节点。这意味着在无尺度网络中，无法找到一个能够代表所有节点特性的节点，这与随机网络和钟形分布的网络形成鲜明对比。 因此，具有幂律度分布的网络被称为“无尺度网络”，是因为它们展示了一种没有特征尺度或特征节点的网络结构，其中枢纽节点对网络的性质起着决定性作用，并且节点的连接度分布遵循幂律分布。 信息冗余，一些要点表达的是同一个意思，逻辑有点混乱。 对于Q4，ChatGPT &gt; 通义千问 &gt; 零一万物 &gt; 腾讯元宝 小结根据文件回答问题，ChatGPT综合表现最优，回答直击要点，逻辑清晰，基本可以看作标准答案；通义千问表现也很好，但是在语言的简洁性和逻辑性上略输ChatGPT；腾讯元宝表现较差，出现大量冗余信息；零一万物表现最差，会出现错误答案，且回答不够详细。 五、文本输出能力 ChatGPT 通义千问 零一万物 腾讯元宝 PPT ✗ ✓ ✓ ✗ Markdown ✓ ✓ ✓ ✓ 思维导图 ✓ ✓ ✗ ✓ 仅通义千问和零一万物可以输出ppt，其中仅通义千问可以根据pdf文件制作ppt，零一万物只能通过word和ppt格式文件制作ppt。 仅通义千问和腾讯元宝有专门的阅读文件模式且能输出思维导图，其他大模型仅能输出文字大纲。 通义千问在阅读模式中提供了“导读”、“翻译”、“脑图”、“笔记”四个功能。其中思维导图是按“定义与特点”、“历史发展”、“未来研究方向”等方面划分层次。 腾讯元宝在阅读模式中提供了“总结”、“精读”、“脑图”三个功能。思维导图按小标题划分层次。 个人认为腾讯元宝的思维导图质量远大于通义千问。 小结通义千问完胜。 六、多知识点层次结构关联ChatGPT 根据你上传的文件内容，关于幂律分布、无尺度网络等相关知识的结构层次关联可以整理如下： 幂律分布的基本概念 幂律分布：指在复杂网络中，大多数节点有少量链接，少数节点拥有大量链接。其数学特征是一条不断递减的曲线，没有峰值。 关键词：大量微小事件、少数重大事件、递减曲线。 幂律分布与随机分布的区别 幂律分布：允许极端事件（如大量链接的枢纽节点）存在，表现为尾部衰减慢。 钟形分布：大多数事件集中在平均值附近，尾部迅速衰减，极端事件极少。 幂律分布中的度指数 度指数：幂律分布公式中的指数参数，反映网络中节点链接数的衰减速率。度指数小，表示更多节点拥有大量链接；度指数大，表示少数节点拥有大量链接。 幂律分布在互联网中的发现 发现过程：研究者最初预计万维网的链接数分布是随机的，但通过数据分析发现，网页之间的链接数遵循幂律分布，揭示出互联网的复杂网络结构。 双对数坐标：幂律分布在双对数坐标系下呈现为线性，进一步证明了少数节点（枢纽节点）的重要性。 无尺度网络的定义与特点 无尺度网络：具有幂律度分布的网络，因为没有明显的特征尺度而得名。即没有特征节点，节点的度数没有集中在某个值。 主要特点：少数枢纽节点连接大量小节点，网络的连通性和稳定性由枢纽节点维持。 无尺度网络与随机网络的对比 随机网络：节点的链接数遵循钟形分布，节点间连接较为均匀，大多数节点拥有相似的链接数。 无尺度网络：节点的链接数遵循幂律分布，少数枢纽节点连接大量节点，枢纽节点是网络的核心。 幂律与复杂系统的涌现 从无序到有序的涌现：幂律分布往往出现在复杂系统从无序向有序转变的过程中，如物质相变或网络结构的形成。 自组织与幂律：幂律分布是复杂网络自组织行为的表现，枢纽节点的形成和稳定性由这种自组织推动。 幂律分布在不同领域的应用 互联网、科学家引用、好莱坞演员网络：这些网络都遵循幂律分布，表明复杂网络背后可能存在统一的数学规律。 经济学中的帕累托法则：80/20定律（帕累托法则）也是幂律分布的一种具体表现，少数资源（财富、影响力）掌握在少数人手中。 这套知识结构从基础概念到应用，逐步揭示了幂律分布在复杂网络中的作用，并通过无尺度网络的特点来展示其在现实中的应用场景，如互联网、社会网络等。 覆盖全面，有对知识点的简单说明。个人认为前四个知识点划分在一起会更好。 通义千问 根据提供的内容，可以将知识点的结构层次关联整理如下： 幂律与复杂网络 幂律分布：描述了大量微小事件和少数非常重大事件并存的现象。 无尺度网络：遵循幂律度分布的网络，具有不均匀性，其中大多数节点只有少量链接，而少数枢纽节点拥有大量的链接。 帕累托原则（80/20定律）：描述了在很多领域中，大部分结果往往由相对较小比例的原因造成。 复杂网络特性 网络中的节点和链接：节点代表个体或实体，链接表示它们之间的关系。 随机网络 vs 无尺度网络：随机网络节点间的连接是均匀的，而无尺度网络则存在高度连接的枢纽节点。 度指数：用于描述网络中恰好有k个链接的节点数遵循幂律的方式，不同的系统有不同的度指数。 从无序到有序的相变 自发涌现：无序系统在特定条件下自发地形成有序结构。 相变的例子：如水结冰、金属磁化等现象。 关联长度：随着系统接近临界点，关联长度按照幂律增加，表明系统内部相关性的变化。 相变理论的发展 卡达诺夫的尺度概念：提出在临界点附近应考虑原子群体的行为而不是单独的原子。 临界指数：描述相变过程中不同物理量的变化规律。 威尔逊的重整化理论：提供了一个统一的框架来解释临界现象，并预测临界指数。 幂律的意义 描述自然和社会系统的自组织行为。 在万维网和其他复杂系统中的发现，揭示了一种新的秩序形式。 指出当系统经历相变时，幂律的出现是混沌向有序过渡的一个标志。 这些知识点之间通过数学模型和实验观察相互联系，共同构成了理解复杂系统行为的基础。从幂律分布到相变过程，再到对自然界和社会现象的广泛适用性，这些概念帮助我们洞察复杂网络背后的普遍规律。 结构划分更合理，但是知识点归类有错误，“度指数”应该放在“幂律与复杂网络”。 零一万物 知识点的结构层次关联可以按照以下层次来组织： 复杂网络的分布规律 幂律分布 无尺度网络 枢纽节点 随机网络与无尺度网络的区别 幂律分布的特性 大量微小事件和少数重大事件并存 没有峰值，不断递减的曲线 度指数和幂指数 无尺度网络的特点 大多数节点只有少数链接 少数枢纽节点拥有大量链接 网络的连通性由枢纽节点保证 相变理论与幂律的关系 从无序到有序的转变 自组织在相变中的作用 临界指数和幂律的关联 帕累托的80/20定律与幂律分布 少数事件或人产生大部分影响 收入不均衡现象 网络中的幂律现象 万维网上链接的分布 好莱坞演员网络 细胞内部网络 物理期刊引用数分布 幂律在不同系统中的普遍性 液体变成气体 铅变成超导体 不同系统中的高度相似性 幂律与自组织秩序 幂律作为自组织和有序的标志 复杂网络中的秩序和一致性 幂律的机制和网络的演化 产生枢纽节点和幂律分布的机制 网络是否处于从无序到有序的转变中 自然界中的网络构建 不同网络的普遍形式和形状 自然界如何织成这些网络 这个结构层次关联图展示了文档中提到的不同概念如何相互关联，以及它们在复杂网络理论中的位置。 结构划分不合理，逻辑混乱，且缺少对知识点的简要概括。 腾讯元宝 复杂网络 幂律分布 定义：无峰，不断递减的曲线 特征：大量微小事件和少数非常重大的事件并存 例子：星球居民身高分布 无尺度网络 定义：遵循幂律度分布的网络 特征：大多数节点只有很少几个链接，通过少数几个高度连接的枢纽节点连接 例子：航空交通系统 帕累托与80/20定律 帕累托：意大利经济学家，提出80/20定律 80/20定律：大多数情况下，80%的效果来自20%的原因 应用：经济学、管理学、网络科学等 幂律分布与度指数 度指数：描述幂律分布的参数 万维网：导入链接数和导出链接数遵循幂律分布 不均匀性，幂律度分布网络的特性 随机网络与无尺度网络的对比 无尺度网络的不均匀特性 链接洞察 幂律分布迫使放弃尺度或特征节点的想法 无尺度网络中枢纽节点的重要性 幂律，复杂网络背后的规律 幂律在自然界和复杂网络中的普遍性 幂律标志着从无序到有序的过渡 自发涌现 水变成冰的相变现象 相变是从无序到有序的过程 有序如何从无序中涌现 相变点附近的临界现象 幂律在相变过程中的普遍性 从“随机”灌木丛到“自组织”舞台 卡达诺夫的尺度不变性概念 威尔逊的重整化理论 幂律无处不在 幂律在各种自然现象和复杂网络中的普遍存在 幂律作为自组织和有序的标志 完全是按照小标题划分的，出现“链接洞察”这样可笑的错误。 小结在多知识点层次结构关联方面，通义千问 &gt; ChatGPT &gt; 零一万物 &gt; 腾讯混元 七、AI知识点扩写扩写“幂律分布”（书本外内容）ChatGPT 幂律分布在复杂系统的研究中扮演着重要角色，它不仅在互联网、社交网络等现代网络结构中广泛存在，还与多种自然现象和社会现象密切相关。联系文章外的相关内容，幂律分布的研究不仅推动了网络科学的发展，也为其他学科（如经济学、物理学和生物学）提供了新的分析工具和理论框架。以下是基于文章外的扩展讨论： 1. 幂律分布在社会现象中的应用1.1 财富分配与经济学中的幂律幂律分布与帕累托的80/20定律紧密相关，经济学中的收入和财富分布常常表现为幂律分布。例如： 财富集中效应：在许多国家中，少数富人占据了大部分的财富，而大多数人仅拥有少量财富。这种不平等的财富分布在不同社会结构中普遍存在，正是帕累托定律的体现。研究表明，无论是全球富人群体，还是具体国家内部，财富的分布都呈现出幂律分布的特征。 公司规模与市场份额：企业规模（如员工数量或收入）往往也符合幂律分布。少数大型跨国公司（如苹果、亚马逊）主导市场，占据大部分份额，而大多数中小企业只占据少量市场。 1.2 犯罪与警务工作幂律分布同样可以应用于犯罪现象分析。例如，少数罪犯可能贡献了大多数的犯罪行为。根据“20%的罪犯犯下了80%的犯罪”的规律，警务部门可以根据这一分布规律更有针对性地分配资源，从而提高社会治安的效率。 2. 自然现象中的幂律分布2.1 地震与自然灾害在地质学中，地震的规模分布也是幂律分布的一个典型案例，即地震频率与震级大小呈反比关系。小地震频繁发生，而大地震则非常罕见，但其破坏性巨大。正如古登堡-里希特定律所描述，震级增加一级，地震的发生频率会减少大约10倍。这种分布模式有助于地质学家估算地震风险，提前做好防灾预案。 2.2 城市规模与人口分布城市人口的分布也符合幂律分布。Zipf定律指出，一个国家或地区的城市规模与城市排名成反比关系。例如，在美国，纽约是最大的城市，洛杉矶作为第二大城市的人口大约是纽约的1/2，芝加哥作为第三大城市的人口大约是洛杉矶的1/2。这种规律在世界范围内广泛存在，揭示了城市发展的内在动力和结构规律。 2.3 物种分布与生态学在生态系统中，物种的种群数量也常常呈幂律分布。大多数物种的个体数量较少，而少数物种（如某些主导物种）个体数量较多。这种分布特征揭示了生态系统中的生物多样性和食物链的稳定性，也帮助科学家预测濒危物种和生态系统的动态变化。 3. 幂律分布在物理与技术领域的应用3.1 幂律与物理系统的相变在物理学中，幂律分布常出现在相变现象的临界点附近。例如，当物质从液态转变为气态或从无序状态转变为有序状态时，系统中的某些量（如簇的大小、磁性强度等）会表现出幂律分布。特别是在临界点处，物质的性质不再依赖于其微观细节，而是呈现出全局的集体行为，物理学家通过幂律分布来描述这些系统的规模不变性和集体现象。 3.2 互联网与网络拓扑结构在网络科学中，互联网的链接分布是幂律分布的一个典型例子。互联网作为一个复杂网络，其节点（网站或服务器）的链接数遵循幂律分布，这意味着大多数节点（如个人网站、小型服务器）拥有较少的链接，而少数节点（如谷歌、脸书等）拥有大量链接，形成枢纽节点。这些枢纽节点决定了网络的稳定性和连通性。 这种幂律分布也解释了互联网的健壮性和脆弱性： 健壮性：网络对随机故障具有很强的抵抗力，即使一些普通节点失效，网络整体仍能保持连通。 脆弱性：如果少数枢纽节点遭到攻击或失效，整个网络可能迅速瓦解，连通性大大降低。 3.3 电力网络与技术系统电力网络和技术基础设施中的负载分布也往往表现为幂律分布。少数变电站、发电厂可能承担了大部分的电力传输和生产，而大多数较小的节点只处理少量电力流。这种分布模式帮助工程师更好地理解系统的脆弱性，并设计出更高效的容错机制。 4. 幂律分布与自组织现象幂律分布在许多情况下与自组织现象密切相关。自组织是指系统内部的个体通过简单的局部规则，能够自发形成全局的有序结构，而不需要外部指令或中央控制。复杂网络、相变过程、以及经济系统的演化，都是自组织现象的典型例子。 自组织临界性：许多复杂系统会自发地达到一种临界状态，在这种状态下，系统的行为呈现出幂律分布。这种现象被称为“自组织临界性”，比如雪崩、森林火灾等，这些系统可以在局部扰动下产生大规模连锁反应。 5. 幂律分布的研究进展与挑战尽管幂律分布已经在许多领域得到了广泛应用，但仍有一些挑战存在： 数据验证：现实中的数据是否严格符合幂律分布仍需谨慎验证。由于幂律的长尾效应，数据采样不足可能导致误判。 模型解释：虽然幂律分布揭示了系统的某些特性，但其背后的形成机制仍需进一步研究。如何通过简单的局部规则生成全局的幂律分布，仍是科学家们正在探索的问题。 实际应用：虽然幂律分布在理论上具有广泛应用，但如何利用这一规律来改善系统的设计和优化，是工程和应用领域的一个重要问题。 总之，幂律分布揭示了复杂系统中极端事件的重要性，联系了不同领域中个体行为与全局结构的关系。从互联网、社交网络到自然界中的地震和城市规模，幂律分布为我们提供了一种理解复杂现象的通用工具。在未来的研究中，进一步探索幂律分布的形成机制及其应用前景，将为复杂系统的理论发展和实际应用提供新的思路。 重点叙述了幂律关系在其他领域的应用以及相关研究。内容非常详细。 通义千问 幂律分布是一种统计分布，它描述的是在很多自然和社会现象中，事件的大小与其发生的频率之间的一种特殊关系。这种分布的特点是少数非常大的事件与大量的小事件共存，并且这些事件的规模和它们出现的概率之间的关系遵循一个特定的数学表达式，即P(x) ∝ x^(-α)，其中P(x)是大于x的事件发生的概率，而α是一个正实数，被称为幂指数或度指数。 幂律分布的普遍性 幂律分布在自然界、社会经济系统、互联网、社交网络等多个领域都有广泛的应用。例如： 自然灾害：地震的震级和发生频率、洪水的规模与发生频率等都呈现出幂律分布。 城市人口：城市的规模（如人口数量）通常遵循幂律分布，这表明大多数城市规模较小，但存在少量非常大的城市。 收入分配：财富分配不均的现象可以用幂律来描述，说明了极少数人拥有大部分财富的情况。 网站链接：网页间的链接数也呈现幂律分布，这意味着绝大多数网页只有少数链接，而少数网页则有大量链接。 社交媒体：用户的粉丝数量或者帖子的转发次数也可能遵循幂律分布。 幂律分布的意义 揭示隐藏秩序：虽然表面上看这些系统似乎是混乱无序的，但幂律分布揭示了它们背后的有序性和一致性。 关键节点的重要性：在具有幂律分布特性的网络中，一些高度连接的关键节点（枢纽节点）对于整个系统的稳定性和连通性至关重要。 预测极端事件：理解幂律分布有助于更好地预测罕见但影响巨大的极端事件的发生概率，比如金融市场的崩盘或大规模传染病爆发。 幂律分布与自组织 幂律分布往往出现在那些通过自我调节过程发展起来的复杂系统中。这些系统不是由外部力量设计出来的，而是通过内部各部分之间的相互作用逐步形成的。这样的自组织过程可以导致幂律分布的形成，因为系统会倾向于优化某些属性，从而使得某些特征比其他特征更加突出。 幂律分布的挑战 尽管幂律分布提供了一个强大的工具来分析和理解复杂系统，但在实际应用中也会遇到一些挑战，比如如何准确地识别数据是否符合幂律分布，以及如何解释幂律分布背后的具体机制。此外，在许多情况下，幂律分布可能只是对数据的一个近似描述，而非精确模型，因此需要结合具体情况和其他方法进行综合分析。 总之，幂律分布为我们提供了理解自然界和社会现象的新视角，它帮助我们认识到即使是在看似随机的环境中，仍然存在着潜在的结构和规律。通过对幂律分布的研究，科学家们能够更好地认识世界的运作方式，并为解决现实世界的问题提供新的思路。 其他领域的应用、意义和实际应用中的问题都有涉及，个人认为更加合理。 零一万物 幂律分布是一种特殊的概率分布，它在很多复杂的自然和社会现象中被观察到。这种分布的特点是没有明显的峰值，而是呈现出一种长尾分布，即大多数事件的规模很小，但偶尔会出现一些非常大的事件。幂律分布可以用一个简单的数学公式来描述，其中包含一个幂指数，这个指数决定了分布的形状。 在文章中提到的万维网上，网页的链接数遵循幂律分布，这意味着大多数网页只有少数链接，而少数网页（枢纽节点）却拥有大量的链接。这种分布模式在很多其他网络中也存在，比如社交网络、生物网络和经济系统。 文章外，幂律分布在许多领域都有应用。例如，在经济学中，帕累托法则（80/20法则）指出，20%的人口拥有80%的财富，这实际上是幂律分布的一个例子。在城市规划中，城市的大小和它们的排名也遵循幂律分布，这就是齐普夫定律。在地质学中，地震的规模和它们的频率也符合幂律分布，这意味着大地震虽然罕见，但它们的影响深远。 此外，幂律分布在物理学中也很重要，特别是在相变理论中。当系统从无序状态转变为有序状态时，例如当物质从液体变成气体时，系统中的某些量会遵循幂律分布。这种分布表明系统正处于临界状态，即从一种状态转变为另一种状态的边缘。 理解幂律分布对于预测和控制复杂系统的行为至关重要。例如，了解金融市场的幂律分布可以帮助投资者更好地管理风险。在公共卫生领域，了解疾病传播的幂律特性可以帮助政策制定者更有效地分配资源以应对疫情。 总之，幂律分布是一个跨学科的概念，它在描述和理解复杂系统的行为方面发挥着关键作用。通过研究幂律分布，科学家们可以揭示隐藏在复杂现象背后的简单规律，从而为预测和控制这些现象提供有力的工具。 没有层次划分，一大段文字不易阅读，侧重点也在于其他领域的应用。 腾讯元宝 幂律分布（Power Law Distribution）是一种在自然界和社会科学领域中广泛存在的概率分布现象。它描述了一种“长尾效应”，即在大量数据中，少数数据点占据了大部分的份额，而大多数数据点则相对较少。幂律分布在许多实际应用场景中都有体现，如城市人口分布、互联网网页链接、社交媒体关注度等。 幂律分布的基本特征 无标度性：幂律分布的一个显著特点是无标度性，即数据的分布不受特定单位或尺度的影响。这意味着在不同尺度上观察数据时，其形态保持一致。 长尾特性：在幂律分布中，尾部的数据点虽然数量少，但它们的总和可能占据整个分布的很大一部分。这种特性使得幂律分布与正态分布等其他常见的概率分布有显著区别。 自相似性：幂律分布具有自相似性，即在不同的时间尺度或空间尺度上，数据的分布模式呈现出相似的结构。 幂律分布的应用领域 社会科学：在社会科学研究中，幂律分布常用于分析社会网络、经济不平等、城市规模分布等问题。例如，城市人口往往遵循幂律分布，少数大城市聚集了大量人口，而众多小城市的人口则相对较少。 网络科学：互联网中的网页链接、用户关注度等都表现出幂律分布的特点。搜索引擎算法如PageRank就是基于网页之间的链接关系，利用幂律分布的特性来确定网页的重要性。 金融领域：金融市场中的价格波动、交易量等也常常服从幂律分布。这有助于理解极端事件（如金融危机）的发生概率及其影响。 生物学与生态学：生物种群的大小、物种多样性以及生态系统中的能量流动等现象，也可以通过幂律分布来描述。 幂律分布的形成机制幂律分布的形成通常与以下几个因素有关： 正反馈机制：当系统中存在正反馈循环时，小的优势会被不断放大，从而导致某些个体或事件在竞争中占据主导地位。 网络效应：在复杂网络中，节点之间的连接往往遵循幂律分布。网络的生长和演化过程中，新节点更倾向于连接到已有较多连接的节点上。 随机过程中的稀有事件：在某些随机过程中，虽然稀有事件发生的概率很低，但一旦发生，它们会产生深远的影响，进而影响整体的分布格局。 幂律分布的统计检验与分析方法为了验证数据是否符合幂律分布，研究者们通常采用以下几种方法： 对数坐标图：将数据取对数后绘制在双对数坐标图上，如果数据点近似呈一条直线，则表明数据服从幂律分布。 最大似然估计法：这是一种更为精确的参数估计方法，可用于确定幂律分布的具体参数。 拟合优度检验：通过比较实际数据与理论幂律分布的拟合程度，来评估幂律分布的适用性。 总之，幂律分布作为一种普遍存在的自然现象和社会现象，为我们理解和解释复杂系统中的各种不平衡和异质性提供了重要的理论工具和分析框架。 最佳回答，涉及基本特征、应用领域、形成机制和分析方法。 小结在这一回合，腾讯元宝 &gt; 通义千问 &gt; ChatGPT &gt; 零一万物 八、AI知识点网搜图仅腾讯元宝能直接给出网搜图，其他模型均只能给出图片建议和关键字 ![](C:\\Users\\13905\\Pictures\\Screenshots\\屏幕截图 2024-10-06 210638.png) 腾讯元宝给出的网搜图 九、AI知识点文生图 “在相变点，系统在两个状态间面临的抉择，就像站在山脊上的登山者要选择从哪一边下山一样。在没有做出决定之前，系统通常左右摇摆，这种摇摆在临界点附近达到极致。”根据这段文字生成图片 ChatGPT ![](C:\\Users\\13905\\Downloads\\DALL·E 2024-10-06 21.28.40 - A metaphorical image representing a phase transition at a critical point, showing a mountain ridge with a climber at the top. The climber stands on th.webp) 完全写实风格，山的两边对比明显，符合文字的主题。 通义千问 偏写实风格，山的两边对比明显，符合文字的主题，和我想象的差不多，excellent！ 零一万物 无法生成图片 腾讯元宝 ![](C:\\Users\\13905\\Pictures\\Screenshots\\屏幕截图 2024-10-06 211736.png) 给出四个图片，卡通画风，大致描绘出了场景，但和文字不搭。 十、总结通过本次调研可得到以下结论 排名 文本阅读能力 通义千问 &gt;&gt; 腾讯元宝 &gt; ChatGPT &gt; 零一万物 文本摘要能力 ChatGPT &gt; 通义千问 &gt; 腾讯元宝 &gt; 零一万物 文本理解能力 ChatGPT &gt; 通义千问 &gt; 腾讯元宝 &gt; 零一万物 文本输出能力 通义千问完胜 多知识点层次结构关联 通义千问 &gt; ChatGPT &gt; 零一万物 &gt; 腾讯混元 AI知识点扩写 腾讯元宝 &gt; 通义千问 &gt; ChatGPT &gt; 零一万物 AI知识点网搜图 仅腾讯元宝能做到 AI知识点文生图 通义千问 &asymp; ChatGPT &gt; 腾讯元宝，零一万物无此功能 输入方式：对于总结特定章节，特定章节输入 &gt; 整本书输入，文件阅读模式 &gt; 对话模式 回答质量/可靠性：ChatGPT &gt; 通义千问 &gt; 腾讯元宝 &gt; 零一万物 功能性：通义千问 &gt;&gt; 腾讯元宝 &gt; 零一万物 &gt; ChatGPT 综合能力：通义千问 &gt; ChatGPT &gt; 腾讯元宝 &gt; 零一万物","link":"/2024/10/06/%E7%A7%91%E7%A0%94%E8%AF%BE%E9%A2%98%E8%B0%83%E7%A0%94%E2%80%94%E2%80%94%E5%A4%A7%E6%A8%A1%E5%9E%8B%E6%B7%B7%E6%88%98/"},{"title":"如何优雅地编写Verilog","text":"Verilog体验优化计划 如何优雅地编写Verilog一、替换ISE默认编辑器ISE仿佛知道自己的默认编辑器很难用，所以允许用户自定义编辑器（ 打开ISE，上方工具栏Edit -&gt; Preferences，在左侧Category选择ISE General -&gt; Editors，第一栏下拉选项选择Custom，在后面一栏输入编辑器的路径，我们以sublime为例，格式如下（大括号内为自己的路径） {D:\\sublime\\Sublime Text\\sublime_text.exe} +$2 $1 设置完成后我们在ISE中点击自己verilog文件就可以自动跳转至指定编辑器了 sublime默认并不支持verilog文件，所以我们还需要安装相关插件 这些插件可以实现基本的语法补全、代码高亮等功能，效果如下 在编辑器编辑完保存后，我们可以返回ISE进行后续的仿真、查看波形图等功能。 二、强大的VScode插件——TerosHDL 具体配置过程见官网：TerosHDL 除了基础的语法补全功能，该插件提供如下功能： 显示项目中各个模块或文件之间的层次结构和依赖关系 实时错误检查 自动模板用于testbench等 自动生成文档 生成状态机的状态转移图 代码格式化 生成原理图 以及许多编辑工具：语法高亮、悬停提示、名称重构、名称重构、代码折叠、求值字面量 此外，这款插件还可以集成外部工具，如使用iverilog编译、GTKWave查看波形，而且好像还支持ISE的命令行工具？期待大家进一步探索。 三、VScode + ISE命令行工具TerosHDL的配置比较麻烦，如果想简单一点，可以使用VScode + ISE命令行工具 详情请见大佬的帖子,通过命令行，更优雅地利用ISE进行开发 在VScode中编写verilog文件后，直接在VScode中新建一个.bat文件，复制以下内容，然后在文件资源管理器中双击打开即可实现一键编译、仿真、查看波形，基本可以脱离ISE。 123456789101112131415161718192021222324@echo offREM 编译&quot;%XILINX%\\bin\\nt64\\fuse.exe&quot; -nodebug -prj mips.prj -o mips.exe mips_tbIF ERRORLEVEL 1 ( echo 编译失败，请检查错误。 pause)REM 运行仿真mips.exe -nolog -tclbatch mips.tclIF ERRORLEVEL 1 ( echo 仿真失败，请检查错误。 pause)REM 查看波形&quot;%XILINX%\\bin\\nt64\\isimgui.exe&quot; -view isim.wdbIF ERRORLEVEL 1 ( echo 查看波形失败，请检查错误。 pause)pause REM 暂停，以便查看输出","link":"/2024/11/19/%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E5%9C%B0%E7%BC%96%E5%86%99Verilog/"},{"title":"CO-P3-设计文档","text":"2024计算机组成原理P3设计文档 P3_document设计草稿本次P3搭建的CPU支持add, sub, ori, lw, sw, beq, lui, nop，begz，bgtz，blez，bltz，bne, j, jal IFU (Instruction Fetch Unit)PC和nPC内置在IFU中，通过branch信号控制PC变换逻辑 端口 方向 描述 Instr[31:0] O 输出32位指令二进制编码 offset[31:0] I 输入branch指令的地址偏移量 reset I 复位信号 branch I 是否branch PC O 用于测试PC Controller用于控制信息通路中的多路选择器，选择正确的功能 add sub ori lw sw beq lui bgez bgtz blez bltz bne jump jal OpCode 000000 000000 001101 100011 101011 000100 001111 000001 000111 000110 000001 000101 000010 000011 Function 100000 100010 xxxxxx xxxxxx xxxxxx xxxxxx xxxxxx 00001 xxxxxx xxxxxx 00000 xxxxxx xxxxxx xxxxxx add sub ori lw sw branch lui jump jal RegDst 01 01 00 00 00 00 00 00 11(const31) ALUSrc 0 0 1 1 1 1 1 0 0 Mem2Reg 00 00 00 01 00 00 00 00 10(PC + 4) RegWrite 1 1 1 1 0 0 1 0 1 MemWrite 0 0 0 0 1 0 0 0 0 nPC_Sel 0 0 0 0 0 1 0 0 0 ExtOp 00 00 01(zero) 10(signed) 10(signed) 10(signed) 10(signed) 00 0 ALUOP&lt;1,0&gt; 00 01 10 00(+) 00(+) 00(+) 11 00 0 jump 0 0 0 0 0 0 0 1 1 beq bgez bgtz blez bltz bne bOp 100000 010000 001000 000100 000010 000001 GRF (General Register File) 引用自P0_Q2 GRF中包含32个32位寄存器，分别对应0~31号寄存器，其中0号寄存器读取的结果恒为0。 ALU (Arithmetic Logic Unit) ALUOP 描述 00 加法 01 减法 10 或 11 立即数加载到高位 EXT (Extend)用于数据扩展 ExtOp 操作 00 无操作 01 0扩展 10 signed扩展 11 1扩展 bChecker (Branch Checker)用于判断是否跳转 端口 方向 描述 bOp I 连接到Controller.bOp，获取branch类型 branch I 连接到Controller.branch，判断是否是branch信号 G[rs] I 连接到GRF.RD1 G[rt] I 连接到GFR.RD2 check O 判断是否符合branch条件，连接到IFU.branch jumpEXT用于实现jump和jal指令，计算 PC31…28 || Instr_index || 00 端口 方向 描述 index I 获取Instr_index，即机器码的后26位 PC I 获取PC的值 ext32 O 下一个PC的值（nPC） 测试方案随机生成数据 -&gt; 导出十六进制文件 -&gt; 自动化工具生成新电路 -&gt; 比对mars运行结果和circ运行结果 randomMipsCmd.py 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758import randomimport timedef generate_register(): &quot;&quot;&quot;生成一个随机寄存器编号（0-31）。&quot;&quot;&quot; return random.randint(0, 31)def generate_immediate(): &quot;&quot;&quot;生成一个随机立即数（0-65535）。&quot;&quot;&quot; return random.randint(0, 65535)def generate_memory_address(): &quot;&quot;&quot;生成一个随机内存地址（0-3071，左移2位）。&quot;&quot;&quot; return random.randint(0, 3071) &lt;&lt; 2def write_instruction(file, instruction): &quot;&quot;&quot;将指令写入文件。&quot;&quot;&quot; file.write(instruction + &quot;\\n&quot;)def main(): random.seed(time.time()) length = int(input(&quot;请输入要生成的指令数量：&quot;)) label_count = 0 with open(&quot;result.asm&quot;, &quot;w&quot;) as file: for _ in range(length): tmp = random.randint(0, 8) match tmp: case 0: write_instruction(file, f&quot;add ${generate_register()}, ${generate_register()}, ${generate_register()}&quot;) case 1: write_instruction(file, f&quot;sub ${generate_register()}, ${generate_register()}, ${generate_register()}&quot;) case 2: write_instruction(file, f&quot;ori ${generate_register()}, ${generate_register()}, {generate_immediate()}&quot;) case 3: write_instruction(file, f&quot;lw ${generate_register()}, {generate_memory_address()}($0)&quot;) case 4: write_instruction(file, f&quot;sw ${generate_register()}, {generate_memory_address()}($0)&quot;) case 5: if label_count &gt;= 1: num1 = generate_register() num2 = generate_register() while num2 == num1: num2 = generate_register() write_instruction(file, f&quot;ori ${num1}, ${num1}, {generate_immediate()}&quot;) write_instruction(file, f&quot;beq ${num1}, ${num2}, label{random.randint(0, label_count - 1)}&quot;) case 6: write_instruction(file, f&quot;lui ${generate_register()}, {generate_immediate()}&quot;) case 7: write_instruction(file, &quot;nop&quot;) case 8: write_instruction(file, f&quot;label{label_count}:&quot;) label_count += 1if __name__ == '__main__': main() autoWrite2Rom.py 123456789101112131415161718192021import re# 读取 ROM 文件内容with open(&quot;python\\\\autoTest_P3\\\\rom.txt&quot;, &quot;r&quot;, encoding=&quot;utf-8&quot;) as f: rom_content = f.read().strip() # 去掉前后空白字符# 读取电路文件with open(&quot;python\\\\autoTest_P3\\\\cpu.circ&quot;, &quot;r&quot;, encoding=&quot;utf-8&quot;) as cur_file: cur_content = cur_file.read()# 使用正则表达式替换 ROM 内容cur_content = re.sub( r'addr/data: 12 32([\\s\\S]*?)&lt;/a&gt;', # 使用非贪婪模式匹配 f'addr/data: 12 32\\n{rom_content}\\n&lt;/a&gt;', cur_content, flags=re.DOTALL # 允许 . 匹配换行符)# 写入新的电路文件with open(&quot;cpu_remake.circ&quot;, &quot;w&quot;, encoding=&quot;utf-8&quot;) as file: file.write(cur_content) 思考题 上面我们介绍了通过 FSM 理解单周期 CPU 的基本方法。请大家指出单周期 CPU 所用到的模块中，哪些发挥状态存储功能，哪些发挥状态转移功能。 状态存储功能：IFU、GRF 状态转移功能：Controller、ALU、EXT、bCheckTT 现在我们的模块中 IM 使用 ROM， DM 使用 RAM， GRF 使用 Register，这种做法合理吗？ 请给出分析，若有改进意见也请一并给出。 合理 ROM是只读存储器，不会被写入，内部数据不会被修改，适合用来储存指令。 RAM可以存取存储器，可以被写入可以被读取，适合用来读取数据。 GRF是寄存器堆，Register具有较高的读写速度，适合用来存储指令中的数据。 在上述提示的模块之外，你是否在实际实现时设计了其他的模块？如果是的话，请给出介绍和设计的思路。 额外设计了Branch Checker，用于判断是否branch，设计思路见”设计草稿” 事实上，实现 nop 空指令，我们并不需要将它加入控制信号真值表，为什么？ nop的指令码是0x00000000，会被翻译为*** sll $0, $0 0***，即把$0的值左移0位存入$0，因为$0的值始终为零不会被改变，所以nop不会带来电路的任何改变。 阅读 Pre 的 “MIPS 指令集及汇编语言” 一节中给出的测试样例，评价其强度（可从各个指令的覆盖情况，单一指令各种行为的覆盖情况等方面分析），并指出具体的不足之处。 强度一般 没有测试到所有的寄存器，也没有考虑到数据溢出的情况","link":"/2024/12/19/P3_%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3/"},{"title":"CO-P4-设计文档","text":"2024计算机组成原理P4设计文档 P4_L0_document信号解释 RegDst（寄存器写入地址） 2’b00: RT 2’b01: RD 2’b11: 5’h1f default: 5’b0 Mem2Reg（寄存器写入数据） 2’b00: alu_c 2’b01: dm_data 2’b10: pc + 32’d4 default: 32’b0 ALUSrc（alu的b操作数选择） 1’b0: grf_RD2 1’b1: ext_ext32 default: 32’b0 ALU_F（ALU计算方式） 4’b0000: add 4’b0001: sub 4’b0010: or 4’b0011: SL16 (lui) 4’b0100: SLL (补0逻辑左移) 4’b0101: SRL (补0逻辑右移) 4‘b0110: SRA (算数右移) ExtOp (扩展操作) 2’b01: 0扩展 2‘b10: 算术扩展（符号位） 2’b11: 1扩展 设计草稿本次CPU支持add, sub, or, ori, lw, sw, lb, lbu, lh, sb, sh, beq, lui, nop，begz，bgtz，blez，bltz，bne, j, jal, jr共23条指令。 mips.v (Top) Ports Port name Direction Type Description clk input reset input Signals Name Type Description pc wire [31:0] if_jump wire if_branch wire instr_out wire [31:0] ifu_offset wire [31:0] OPCODE wire [5:0] FUNCT wire [5:0] RS wire [4:0] RT wire [4:0] RD wire [4:0] SHAMT wire [4:0] IMM wire [15:0] INDEX wire [25:0] bOp_out wire [5:0] RegDst_out wire [1:0] ALUSrc_out wire Mem2Reg_out wire [1:0] RegWrite_out wire MemWrite_out wire branch_out wire ExtOp_out wire [1:0] ALUOP_out wire [1:0] jumpSrc_out wire [1:0] dm_data wire [31:0] ext_ext32 wire [31:0] grf_RD1 wire [31:0] grf_RD2 wire [31:0] alu_B wire [31:0] alu_C wire [31:0] grf_WA wire [4:0] grf_WD wire [31:0] jumpext_ext32 wire [31:0] Instantiations ifu: IFU controller: Controller grf: GRF alu: ALU dm: DM ext: EXT jumpext: jumpEXT bcheck: bCheck IFU.v Ports Port name Direction Type Description clk input reset input jump input branch input offset input [31:0] PC output [31:0] Instr output [31:0] Controller.v Ports Port name Direction Type Description OpCode input [5:0] Funct input [5:0] rt input [4:0] jump output jumpSrc output [1:0] bOp output [5:0] RegDst output [1:0] ALUSrc output Mem2Reg output [1:0] RegWrite output MemWrite output branch output ExtOp output [1:0] ALUOP output [1:0] 信号映射表 OpCode Funct RT add 000000 100000 sub 000000 100010 or 000000 100101 SLL 000000 000000 SRL 000000 000010 SRA 000000 000011 ori 001101 lw 100011 sw 101011 lb 100000 lbu 100100 lh 100001 sb 101000 sh 101001 beq 000100 lui 001111 bgez 000001 00001 bgtz 000111 blez 000110 bltz 000001 bne 000101 00000 jump 000010 jal 000011 jr 000000 001000 add sub ori SLL SRL SRA or lw sw lb lbu lh sb sh branch lui jump jal jr RegDst 01 01 00 01 01 01 01 00 00 00 00 00 00 00 00 00 00 11(const31) 00 ALUSrc 0 0 1 0 0 0 0 1 1 1 1 1 1 1 1 1 0 0 0 Mem2Reg 00 00 00 00 00 00 00 01 00 01 01 01 00 00 00 00 00 10(PC + 4) 00 RegWrite 1 1 1 1 1 1 1 1 0 1 1 1 0 0 0 1 0 1 0 MemWrite 0 0 0 0 0 0 0 0 1 0 0 0 1 1 0 0 0 0 0 branch 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 ExtOp 00 00 01(zero) 0 0 0 00 ]10(signed) 10(signed) 10 10 10 10 10 10(signed) 10(signed) 00 0 0 ALUOP&lt;3,0&gt; 0000 0001 0010 0100 0101 0110 0010 0000(+) 0000(+) 0000 0000 0000 0000 0000 0000(+) 0011 0000 0000 0000 jumpSrc 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 01 01 10 jump 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 ls_type 00 00 01 10 11 01 11 GRF.v Ports Port name Direction Type Description A1 input [4:0] A2 input [4:0] A3 input [4:0] WD input [31:0] clk input reset input WE input pc input [31:0] RD1 output [31:0] RD2 output [31:0] DM.v Ports Port name Direction Type Description A input [31:0] D_input input [31:0] str input clk input pc input [31:0] D_output output [31:0] ALU.v Ports Port name Direction Type Description A input [31:0] B input [31:0] shamt input [4:0] F input [3:0] C output [31:0] bCheck.v Ports Port name Direction Type Description Grs input [31:0] Grt input [31:0] bOp input [5:0] branch input check output EXT.v Ports Port name Direction Type Description imm16 input [15:0] ExtOp input [1:0] ext32 output [31:0] jumpEXT.v Ports Port name Direction Type Description index input [25:0] pc input [31:0] ext32 output [31:0] 测试方案 利用魔改Mars： 直接比较ISE得输出和Mars的输出 课上环境：在Isim中将32个Reg和内存添加到波形图中，对比最终结果 简单的测试代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#GRF REG_WRITE TESTori $1, 125ori $2, 300ori $3, $0, 5ori $4, $0, 1024ori $5, $0, 56ori $6, $0,125ori $7, $0, 525ori $8, $0, 10086ori $9, $0,14514ori $10, $0, 625ori $11, $0, 168ori $12, $0, 576ori $13, $0, 2048ori $14, $0, 6666ori $15, $0, 424ori $16, $0, 2024ori $16, $0, 1101ori $17, $0, 2203ori $18, $0, 2306ori $19, $0, 999ori $20, $0, 2005ori $21, $0, 0ori $22, $0, 176ori $23, $0, 616ori $24, $0, 1213ori $25, $0, 1314ori $26, $0, 888ori $27, $0, 545ori $28, $0, 28#LUI TESTlui $1, 424lui $12, 500lui $24, 233#ADD or SUB TESTadd $21, $27, $28 sub $21, $27, $28#MEMORY TESTsw $21, 0($0)lw $28, 0($0)#BRANCH TESTbeq $24, $25, beq_label_falseori $24, $0, 1314beq $24, $25, beq_label_truebeq_label_false:ori $5, $0, 666beq_label_true:ori $5, $0, 667#JUMP TESTjal functionori $5, $0, 0ori $5, $0, 1ori $5, $0, 9j jump_labelfunction:ori $5, $0, 1111jr $rajump_label:nopnopnopbgez $0, bgez_labelori $1, $0, 11451bgez_label:ori $1, $0, -10bltz $1, bltz_labelori $5, $0, 1314ori $6, $0, 156bltz_label:bne $0, $1, bne_labelori $5, $0, 131ori $6, $0, 15bne_label:lui $12, 2333 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748//STDOUT@00003000: $ 1 &lt;= 0000007d@00003004: $ 2 &lt;= 0000012c@00003008: $ 3 &lt;= 00000005@0000300c: $ 4 &lt;= 00000400@00003010: $ 5 &lt;= 00000038@00003014: $ 6 &lt;= 0000007d@00003018: $ 7 &lt;= 0000020d@0000301c: $ 8 &lt;= 00002766@00003020: $ 9 &lt;= 000038b2@00003024: $10 &lt;= 00000271@00003028: $11 &lt;= 000000a8@0000302c: $12 &lt;= 00000240@00003030: $13 &lt;= 00000800@00003034: $14 &lt;= 00001a0a@00003038: $15 &lt;= 000001a8@0000303c: $16 &lt;= 000007e8@00003040: $16 &lt;= 0000044d@00003044: $17 &lt;= 0000089b@00003048: $18 &lt;= 00000902@0000304c: $19 &lt;= 000003e7@00003050: $20 &lt;= 000007d5@00003054: $21 &lt;= 00000000@00003058: $22 &lt;= 000000b0@0000305c: $23 &lt;= 00000268@00003060: $24 &lt;= 000004bd@00003064: $25 &lt;= 00000522@00003068: $26 &lt;= 00000378@0000306c: $27 &lt;= 00000221@00003070: $28 &lt;= 0000001c@00003074: $ 1 &lt;= 01a80000@00003078: $12 &lt;= 01f40000@0000307c: $24 &lt;= 00e90000@00003080: $21 &lt;= 0000023d@00003084: $21 &lt;= 00000205@00003088: *00000000 &lt;= 00000205@0000308c: $28 &lt;= 00000205@00003094: $24 &lt;= 00000522@000030a0: $ 5 &lt;= 0000029b@000030a4: $31 &lt;= 000030a8@000030b8: $ 5 &lt;= 00000457@000030a8: $ 5 &lt;= 00000000@000030ac: $ 5 &lt;= 00000001@000030b0: $ 5 &lt;= 00000009@000030d4: $ 1 &lt;= ffff0000@000030d8: $ 1 &lt;= fffffff6@000030dc: $ 1 &lt;= fffffff6@000030f8: $12 &lt;= 091d0000 思考题 阅读下面给出的 DM 的输入示例中（示例 DM 容量为 4KB，即 32bit × 1024字），根据你的理解回答，这个 addr 信号又是从哪里来的？地址信号 addr 位数为什么是 [11:2] 而不是 [9:0] ？ addr信号来源于ALU的结果输出端。 输入信号为按字节索引的地址，而DM的存储方式为按字索引，取addr[11:2]即等于addr[9:0] &lt;&lt; 2 思考上述两种控制器设计的译码方式，给出代码示例，并尝试对比各方式的优劣。 12345678910111213141516always @(*) begin if (OpCode == 6'b000000) begin if (Funct == 6'b100000) begin //add RegDst &lt;= 2'b01; ALUSrc &lt;= 1'b0; Mem2Reg &lt;= 2'b00; RegWrite &lt;= 1'b1; MemWrite &lt;= 1'b0; branch &lt;= 1'b0; ExtOp &lt;= 2'b00; ALUOP &lt;= 2'b00; jumpSrc &lt;= 2'b00; jump &lt;= 1'b0; end end 1234567891011121314always @(*) begin if (OpCode == 6'b100011 || OpCode == 6'b101011 || OpCode == 6'b000100 || OpCode == 6'b001111) begin ExtOp &lt;= 2'b10; end else if (OpCode == 6'b001101) begin ExtOp &lt;= 2'b01; end else begin ExtOp &lt;= 2'b00; endend 记录指令对应的控制信号如何取值：方便添加新指令。 记录控制信号每种取值所对应的指令：方便添加控制信号。 在相应的部件中，复位信号的设计都是同步复位，这与 P3 中的设计要求不同。请对比同步复位与异步复位这两种方式的 reset 信号与 clk 信号优先级的关系。 异步复位reset信号优先，同步复位clk信号优先。 C 语言是一种弱类型程序设计语言。C 语言中不对计算结果溢出进行处理，这意味着 C 语言要求程序员必须很清楚计算结果是否会导致溢出。因此，如果仅仅支持 C 语言，MIPS 指令的所有计算指令均可以忽略溢出。 请说明为什么在忽略溢出的前提下，addi 与 addiu 是等价的，add 与 addu 是等价的。提示：阅读《MIPS32® Architecture For Programmers Volume II: The MIPS32® Instruction Set》中相关指令的 Operation 部分。 The term “unsigned” in the instruction name is a misnomer; this operation is 32-bit modulo arithmetic that does not trap on overflow. This instruction is appropriate for unsigned arithmetic, such as address arithmetic, or integer arithmetic environments that ignore overflow, such as C language arithmetic. addu和add的区别、addi和addiu的区别均仅在与是否有溢出判断，故忽略溢出时效果是一样的。","link":"/2024/12/19/P4_%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3/"},{"title":"CO-P5-设计文档","text":"2024计算机组成原理P5设计文档 P5_documentHazard.v input explain Instr_ID ID阶段的指令码 Instr_EX EX阶段的指令码 Instr_MA MA阶段的指令码 A3_EX EX阶段的寄存器写入地址 A3_MA MA阶段的寄存器写入地址 T_use表格（需求者）指令位于ID级时，还需要多少个周期才必须要使用数据。 $T_{use}(rs)$ $T_{use}(rt)$ add 1 1 sub 1 1 ori 1 lw 1 sw 1 2 beq 0 0 lui 1 jal jr 0 nop 12345678wire [1:0] Tuse_rs = (add_ID | sub_ID | ori_ID | lw_ID | sw_ID | lui_ID)?2'b01: (beq_ID | jr_ID)? 2'b00: 2'b11; wire [1:0] Tuse_rt = (add_ID | sub_ID)? 2'b01: (sw_ID)? 2'b10: (beq_ID)? 2'b00: 2'b11; T_new表格（供给者）T_new: 供给指令位于某个流水级时还需要多少个周期才可以计算出结果并存储到流水寄存器中。 早于需求指令进入流水线的供给者还需要多少cycle能够产生需求者需要的寄存器值。 Intsr 功能部件(结果来源) EX MA WB add ALU 1 sub ALU 1 ori ALU 1 lw DM 2 1 0 sw beq lui ALU 1 jal PC 0 0 0 jr nop 123wire [1:0] Tnew_EX = (add_EX | sub_EX | ori_EX | lui_EX)? 2'b01: (lw_EX)? 2'b10: 2'b00;wire [1:0] Tnew_MA = lw_MA?2'b01:2'b00; rs策略矩阵 $T_{use} \\textbackslash \\space T_{new}$ EX EX EX MA MA MA WB WB WB ALU DM PC ALU DM PC ALU DM PC 1 2 0 0 1 0 0 0 0 0 S S F F S F F F F 1 F S F F F F F F F rt策略矩阵 $T_{use} \\textbackslash \\space T_{new}$ EX EX EX MA MA MA WB WB WB ALU DM PC ALU DM PC ALU DM PC 1 2 0 0 1 0 0 0 0 0 S S F F S F F F F 1 F S F F F F F F F 2 F F F F F F F F F 如何理解策略矩阵 策略矩阵针对的是AT法中的Time部分，具体判断阻塞还是转发需要综合Adress部分 对于ALU型指令，如add，只需要关注 $T_{new}$ 的ALU一列，其表示在当前流水级下，还有多少周期才能计算出结果并存入流水级寄存器。 123456wire Stall_RS_EX = (Tuse_rs &lt; Tnew_EX) &amp; (A3_EX == RS_ID &amp; RS_ID != 0);wire Stall_RS_MA = (Tuse_rs &lt; Tnew_MA) &amp; (A3_MA == RS_ID &amp; RS_ID != 0);wire Stall_RT_EX = (Tuse_rt &lt; Tnew_EX) &amp; (A3_EX == RT_ID &amp; RT_ID != 0);wire Stall_RT_MA = (Tuse_rt &lt; Tnew_MA) &amp; (A3_MA == RT_ID &amp; RT_ID != 0);assign Stall = Stall_RS_EX | Stall_RS_MA | Stall_RT_EX | Stall_RT_MA; Forward in mips.v数据的供给者 EX_MA级流水线寄存器 123wire [31:0] forward_EX_MA = (RegWrite_MA &amp;&amp; (Mem2Reg_MA == 2'b00))? ALU_C_MA: (RegWrite_MA &amp;&amp; (Mem2Reg_MA == 2'b10))? pc_add4_MA + 32'd4: 32'h404; MA_WB级流水线寄存器 12345assign grf_WD = (Mem2Reg_WB == 2'b00) ? ALU_C_WB : (Mem2Reg_WB == 2'b01) ? dm_data_WB : (Mem2Reg_WB == 2'b10) ? pc_add4_WB + 32'd4 : 32'd0; wire [31:0] forward_MA_WB = RegWrite_WB? grf_WD: 32'h405; 数据需求者 ID级 1234567wire [31:0] RD1_ID_valid = ((RS_ID == A3_MA) &amp;&amp; (A3_MA != 5'b0))? forward_EX_MA: ((RS_ID == A3_WB) &amp;&amp; (A3_WB != 5'b0))? forward_MA_WB: RD1_ID; wire [31:0] RD2_ID_valid = ((RT_ID == A3_MA) &amp;&amp; (A3_MA != 5'b0))? forward_EX_MA: ((RT_ID == A3_WB) &amp;&amp; (A3_WB != 5'b0))? forward_MA_WB: RD2_ID; EX级 12345678910111213//forward--select valid ALU_A and ALU_Bwire [31:0] ALU_A_EX_valid = ((RS_EX == A3_MA) &amp;&amp; (A3_MA != 5'b0))? forward_EX_MA: ((RS_EX == A3_WB) &amp;&amp; (A3_WB != 5'b0))? forward_MA_WB: RD1_EX; wire [31:0] Grt_EX_valid = ((RT_EX == A3_MA) &amp;&amp; (A3_MA != 5'b0))? forward_EX_MA: ((RT_EX == A3_WB) &amp;&amp; (A3_WB != 5'b0))? forward_MA_WB: RD2_EX;//将目前正确的Grt值，流水到MA级供sw指令使用，也可供R-type-ALU指令使用 wire [31:0] Grt_MA_valid; wire [31:0] ALU_B_EX_valid = (ALUSrc_EX == 1'b0) ? Grt_EX_valid: (ALUSrc_EX == 1'b1) ? ext32_EX : 32'b0; MA级 再一次获取转发数据，确保DM中的Grt值是正确的 1wire [31:0] Grt_MA_valid_valid = ((RT_MA == A3_WB) &amp;&amp; (A3_WB != 5'd0))? forward_MA_WB: Grt_MA_valid; 流水线寄存器 PC IF_ID ID_EX EX_MA MA_WB en nStall nStall true false true clr null false Stall true false RegDst ExtOp jump jumpSrc branch bOp ALUSrc ALUOP MemWrite ls_type Mem2Reg RegWrite 作用阶段 EX ID ID ID ID ID EX EX MA MA WB WB IF_ID ID_EX 1 1 1 1 1 1 1 EX_MA 1 1 1 1 MA_WB 1 1 Stall ExplainID级指令静止，EX级插入一个nop PC不写入新数据 IF_ID寄存器不写入新数据 ID_EX寄存器清零，即插入nop(0x00000000) Logic12345678910111213141516171819202122module Stage_Reg( input clk, input reset, input en, input clr, input [31:0] data, output reg [31:0] data_out ); initial begin data_out &lt;= 0; end always @(posedge clk) begin if (reset || clr) begin data_out &lt;= 0; end else begin if (en) begin data_out &lt;= data; end end end 信号解释jumpSrc (2-bit) jumpSrc type 2’b00 branch 2’b01 jump 2’b10 jr 123assign next_pc_ID = (jumpSrc_ID == 2'b00) ? branch_offset_ID: (jumpSrc_ID == 2'b01) ? jumpExt32_ID: (jumpSrc_ID == 2'b10) ? RD1_ID_valid: 32'h404; Mem2Reg (2-bit) Mem2Reg type 2‘b00 ALU 2’b01 lw 2’b10 link 123assign grf_WD = (Mem2Reg_WB == 2'b00) ? ALU_C_WB : (Mem2Reg_WB == 2'b01) ? dm_data_WB : (Mem2Reg_WB == 2'b10) ? pc_add4_WB + 32'd4 : 32'd0; RegDst (2-bit) RegDst type 2’b00 无需写入寄存器的指令 2’b01 R-type，写入rd寄存器 2’b10 I-type，写入rt寄存器 2’b11 link，写入$ra ($31) 12345assign A3_EX = (RegDst_EX == 2'b00)? 5'b0: //null (RegDst_EX == 2'b01)? RD_EX: (RegDst_EX == 2'b10)? RT_EX: (RegDst_EX == 2'b11)? 5'h1f: 5'b00000; ALU (4-bit) ALU type 4’b0000 add 4’b0001 sub 4’b0010 or 4’b0011 lui 123456789always @(*) begin case(F) `ADD: C = A + B; `SUB: C = A - B; `OR: C = A | B; `SL16: C = B &lt;&lt; 16; default:C = 0; endcase end 测试方案指令分类R-type ALU型指令（Grd &lt;- Grs ? Grt）——（add、sub、or） ALU型指令（Grd &lt;- Grt ？ shamt）——（sll、srl、sra） 跳转型指令（PC &lt;- Grs）——（jr） I-type ALU-Imm型指令（Grt &lt;- Grs ？ imm）——（ori、lui） Memory-Store型指令（Memory[Grs + offset] &lt;- Grt）——（sw、sb、sh） Memory-load型指令（Grt &lt;- Memory[Grs + offset]）——（lw、lb、lbu、lh） Branch型指令（Grs ? Grt，PC &lt;- PC + 4 + offset）——（beq、bgez、bgtz、blez、bltz、bne） J-type J-link型指令 —— (jal) 无条件Jump型指令 IF级 ID级 EX级 MA级 WB级 R-ALU 读取数据（Grs、Grt） 计算数据 写入数据 R-jump 读取数据并跳转 I-imm 读取数据（Grt、imm） 计算数据 写入数据 I-store 读取数据（Grs+offset、Grt） 计算数据（地址） 写入数据 I-load 读取数据（Grs+offset、Grt） 计算数据（地址） 读取数据 写入数据 I-branch 读取数据（Grs、Grt）比较数据并跳转 J-link 扩展数据并跳转 传递跳转PC 传递跳转PC 写入pc+8 测试步骤 编写测试代码 包括所有阻塞情况 测试所有转发通路 可利用课程组提供的分析工具对代码测试强度进行评估 将ISE输出与Mars输出比对 可利用同学开发评测机进行快速比对 大量随机数据强测 代码生成思路参照P4数据生成思路 123456789101112131415161718192021222324252627282930313233343536373839import random SUPPORTED_INSTRUCTIONS = [ &quot;add&quot;, &quot;sub&quot;, &quot;and&quot;, &quot;ori&quot;, &quot;lui&quot;, # arithmetic &quot;lw&quot;, &quot;sw&quot;, # storage &quot;beq&quot;, &quot;bne&quot;, # B-type &quot;j&quot;, &quot;jal&quot;, # jump &quot;nop&quot; # command jr will be generated according to the use of command jal ] REGISTERS = [f&quot;${i}&quot; for i in range(32) if i != 1 and i &lt; 26] def weighted_choice(): return random.choices(REGISTERS, weights=REGISTER_WEIGHTS, k=1)[0] def generate_random_instruction(half): instruction = random.choice(SUPPORTED_INSTRUCTIONS) if instruction in [&quot;add&quot;, &quot;sub&quot;, &quot;and&quot;]: # add $t0, $t1, $t2 : op rd, rs, rt rd = weighted_choice() rs = weighted_choice() rt = weighted_choice() return f&quot;{instruction} {rd}, {rs}, {rt}&quot; # other instructions... def main(): # parser... high_weight_registers = random.sample(REGISTERS, 4) # print(f&quot;High weight registers: {high_weight_registers}&quot;) global REGISTER_WEIGHTS REGISTER_WEIGHTS = [4 if reg in high_weight_registers else 1 for reg in REGISTERS] mips_code = generate_mips_code(args.num_instructions) 思考题 我们使用提前分支判断的方法尽早产生结果来减少因不确定而带来的开销，但实际上这种方法并非总能提高效率，请从流水线冒险的角度思考其原因并给出一个指令序列的例子。 提前分支判断会带增加阻塞的情况，从而降低效率 lw $1, 0($0)ori $2, $0, 514 beq $1, $2, label 对于上述代码，需要阻塞两次 因为延迟槽的存在，对于 jal 等需要将指令地址写入寄存器的指令，要写回 PC + 8，请思考为什么这样设计？ 因为，jr返回时应该执行延迟槽后面的指令 我们要求所有转发数据都来源于流水寄存器而不能是功能部件（如 DM、ALU），请思考为什么？ 减少组合逻辑与时序逻辑的组合，减少毛刺，使流水线分级更清晰 我们为什么要使用 GPR 内部转发？该如何实现？ 解决结构冒险。由于流水线中grf的读写在不同级，所以当同时读和写grf时会出现结构冒险 assign RD1 = (A3!=0 &amp; A1==A3 &amp; WE) ? WD : grf[A1];assign RD2 = (A3!=0 &amp; A2==A3 &amp; WE) ? WD : grf[A2]; 我们转发时数据的需求者和供给者可能来源于哪些位置？共有哪些转发数据通路？ 见上文 在课上测试时，我们需要你现场实现新的指令，对于这些新的指令，你可能需要在原有的数据通路上做哪些扩展或修改？提示：你可以对指令进行分类，思考每一类指令可能修改或扩展哪些位置。 添加控制信号 可能需要修改ALU 修改顶层模块，可能需要添加wire 可能需要修改阻塞逻辑 简要描述你的译码器架构，并思考该架构的优势以及不足。、 集中式译码。只需一次译码，然后流水各个信号。优势：资源占用小，代码量小不足：流水信号比较麻烦，添加控制信号时比较麻烦 [P5 选做] 请详细描述你的测试方案及测试数据构造策略。 见测试方案 [P5、P6 选做] 请评估我们给出的覆盖率分析模型的合理性，如有更好的方案，可一并提出。","link":"/2024/12/19/P5-%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3/"},{"title":"CO-P6-设计文档","text":"2024计算机组成原理P6设计文档 P6_documentHazard.v input explain Instr_ID ID阶段的指令码 Instr_EX EX阶段的指令码 Instr_MA MA阶段的指令码 A3_EX EX阶段的寄存器写入地址 A3_MA MA阶段的寄存器写入地址 busy 乘除槽正在进行计算 start 乘除槽开始进行计算 T_use表格（需求者）指令位于ID级时，还需要多少个周期才必须要使用数据。 add sub ori lw sw beq lui jal jr nop $T_{use}(rs)$ 1 1 1 1 1 0 1 0 $T_{use}(rt)$ 1 1 2 0 P6_new and or slt sltu addi andi lb lh sb sh $T_{use}(rs)$ 1 1 1 1 1 1 1 1 1 1 $T_{use}(rt)$ 1 1 1 1 2 2 P6_new mult multu div divu mfhi mflo mthi mtlo bne $T_{use}(rs)$ 1 1 1 1 1 1 0 $T_{use}(rt)$ 1 1 1 1 0 12345678wire [1:0] Tuse_rs = (add_ID | sub_ID | ori_ID | lw_ID | sw_ID | lui_ID | and_ID | or_ID | slt_ID | sltu_ID | addi_ID | andi_ID | lb_ID | lh_ID | sb_ID | sh_ID | mthi_ID | mtlo_ID | mult_ID | multu_ID | div_ID | divu_ID)?2'b01: (beq_ID | jr_ID | bne_ID)? 2'b00: 2'b11; wire [1:0] Tuse_rt = (add_ID | sub_ID | and_ID | or_ID | slt_ID |sltu_ID | mult_ID | multu_ID | div_ID | divu_ID)? 2'b01: (sw_ID | sb_ID | sh_ID)? 2'b10: (beq_ID | bne_ID)? 2'b00: 2'b11; T_new表格（供给者）T_new: 供给指令位于某个流水级时还需要多少个周期才可以计算出结果并存储到流水寄存器中。 早于需求指令进入流水线的供给者还需要多少cycle能够产生需求者需要的寄存器值。 Intsr add sub ori lw sw beq lui jal jr nop 功能部件(结果来源) ALU ALU ALU DM ALU PC EX 1 1 1 2 1 0 MA 1 0 WB 0 0 P6_new_Intsr and or slt sltu addi andi lb lh sb sh 功能部件(结果来源) ALU ALU ALU ALU ALU ALU DM DM EX 1 1 1 1 1 1 2 2 MA 1 1 WB 0 0 P6_new_Intsr mult multu div divu mfhi mflo mthi mtlo bne 功能部件(结果来源) mdb mdb EX 1 1 MA WB 123wire [1:0] Tnew_EX = (add_EX | sub_EX | ori_EX | lui_EX | and_EX | or_EX | slt_EX | sltu_EX | addi_EX | andi_EX | mfhi_EX | mflo_EX)? 2'b01: (lw_EX | lb_EX | lh_EX)? 2'b10: 2'b00;wire [1:0] Tnew_MA = (lw_MA | lb_MA | lh_MA)?2'b01:2'b00; rs策略矩阵 $T_{use} \\textbackslash \\space T_{new}$ EX EX EX MA MA MA WB WB WB ALU DM PC ALU DM PC ALU DM PC 1 2 0 0 1 0 0 0 0 0 S S F F S F F F F 1 F S F F F F F F F rt策略矩阵 $T_{use} \\textbackslash \\space T_{new}$ EX EX EX MA MA MA WB WB WB ALU DM PC ALU DM PC ALU DM PC 1 2 0 0 1 0 0 0 0 0 S S F F S F F F F 1 F S F F F F F F F 2 F F F F F F F F F 如何理解策略矩阵 策略矩阵针对的是AT法中的Time部分，具体判断阻塞还是转发需要综合Adress部分 对于ALU型指令，如add，只需要关注 $T_{new}$ 的ALU一列，其表示在当前流水级下，还有多少周期才能计算出结果并存入流水级寄存器。 1234567wire Stall_RS_EX = (Tuse_rs &lt; Tnew_EX) &amp; (A3_EX == RS_ID &amp; RS_ID != 0);wire Stall_RS_MA = (Tuse_rs &lt; Tnew_MA) &amp; (A3_MA == RS_ID &amp; RS_ID != 0);wire Stall_RT_EX = (Tuse_rt &lt; Tnew_EX) &amp; (A3_EX == RT_ID &amp; RT_ID != 0);wire Stall_RT_MA = (Tuse_rt &lt; Tnew_MA) &amp; (A3_MA == RT_ID &amp; RT_ID != 0);wire Stall_md = ((busy | start) &amp; (mult_ID | multu_ID | div_ID | divu_ID | mfhi_ID | mflo_ID | mthi_ID | mtlo_ID));assign Stall = Stall_RS_EX | Stall_RS_MA | Stall_RT_EX | Stall_RT_MA | Stall_md; Forward in mips.v数据的供给者 EX_MA级流水线寄存器 123wire [31:0] forward_EX_MA = (RegWrite_MA &amp;&amp; (Mem2Reg_MA == 2'b00))? ALU_C_MA: (RegWrite_MA &amp;&amp; (Mem2Reg_MA == 2'b10))? pc_add4_MA + 32'd4: 32'h404; MA_WB级流水线寄存器 12345assign grf_WD = (Mem2Reg_WB == 2'b00) ? ALU_C_WB : (Mem2Reg_WB == 2'b01) ? dm_data_WB : (Mem2Reg_WB == 2'b10) ? pc_add4_WB + 32'd4 : 32'd0; wire [31:0] forward_MA_WB = RegWrite_WB? grf_WD: 32'h405; 数据需求者 ID级 1234567wire [31:0] RD1_ID_valid = ((RS_ID == A3_MA) &amp;&amp; (A3_MA != 5'b0))? forward_EX_MA: ((RS_ID == A3_WB) &amp;&amp; (A3_WB != 5'b0))? forward_MA_WB: RD1_ID; wire [31:0] RD2_ID_valid = ((RT_ID == A3_MA) &amp;&amp; (A3_MA != 5'b0))? forward_EX_MA: ((RT_ID == A3_WB) &amp;&amp; (A3_WB != 5'b0))? forward_MA_WB: RD2_ID; EX级 12345678910111213//forward--select valid ALU_A and ALU_Bwire [31:0] ALU_A_EX_valid = ((RS_EX == A3_MA) &amp;&amp; (A3_MA != 5'b0))? forward_EX_MA: ((RS_EX == A3_WB) &amp;&amp; (A3_WB != 5'b0))? forward_MA_WB: RD1_EX; wire [31:0] Grt_EX_valid = ((RT_EX == A3_MA) &amp;&amp; (A3_MA != 5'b0))? forward_EX_MA: ((RT_EX == A3_WB) &amp;&amp; (A3_WB != 5'b0))? forward_MA_WB: RD2_EX;//将目前正确的Grt值，流水到MA级供sw指令使用，也可供R-type-ALU指令使用 wire [31:0] Grt_MA_valid; wire [31:0] ALU_B_EX_valid = (ALUSrc_EX == 1'b0) ? Grt_EX_valid: (ALUSrc_EX == 1'b1) ? ext32_EX : 32'b0; MA级 再一次获取转发数据，确保DM中的Grt值是正确的 1wire [31:0] Grt_MA_valid_valid = ((RT_MA == A3_WB) &amp;&amp; (A3_WB != 5'd0))? forward_MA_WB: Grt_MA_valid; 流水线寄存器 PC IF_ID ID_EX EX_MA MA_WB en nStall nStall true false true clr null false Stall true false RegDst ExtOp jump jumpSrc branch bOp ALUSrc ALUOP mdOp load_type store_type MemWrite Mem2Reg RegWrite 作用阶段 EX ID ID ID ID ID EX EX EX MA MA MA WB WB IF_ID ID_EX 1 1 1 1 1 1 1 1 1 EX_MA 1 1 1 1 1 MA_WB 1 1 Stall ExplainID级指令静止，EX级插入一个nop PC不写入新数据 IF_ID寄存器不写入新数据 ID_EX寄存器清零，即插入nop(0x00000000) Logic12345678910111213141516171819202122module Stage_Reg( input clk, input reset, input en, input clr, input [31:0] data, output reg [31:0] data_out ); initial begin data_out &lt;= 0; end always @(posedge clk) begin if (reset || clr) begin data_out &lt;= 0; end else begin if (en) begin data_out &lt;= data; end end end 信号解释jumpSrc (2-bit) jumpSrc type 2’b00 branch 2’b01 jump 2’b10 jr 123assign next_pc_ID = (jumpSrc_ID == 2'b00) ? branch_offset_ID: (jumpSrc_ID == 2'b01) ? jumpExt32_ID: (jumpSrc_ID == 2'b10) ? RD1_ID_valid: 32'h404; Mem2Reg (2-bit) Mem2Reg type 2‘b00 ALU 2’b01 lw 2’b10 link 123assign grf_WD = (Mem2Reg_WB == 2'b00) ? ALU_C_WB : (Mem2Reg_WB == 2'b01) ? dm_data_WB : (Mem2Reg_WB == 2'b10) ? pc_add4_WB + 32'd4 : 32'd0; RegDst (2-bit) RegDst type 2’b00 无需写入寄存器的指令 2’b01 R-type，写入rd寄存器 2’b10 I-type，写入rt寄存器 2’b11 link，写入$ra ($31) 12345assign A3_EX = (RegDst_EX == 2'b00)? 5'b0: //null (RegDst_EX == 2'b01)? RD_EX: (RegDst_EX == 2'b10)? RT_EX: (RegDst_EX == 2'b11)? 5'h1f: 5'b00000; ALUOp (4-bit) ALUOp type 4’b0000 add 4’b0001 sub 4’b0010 or 4’b0011 lui 4’b0100 and 4’b0101 slt 4’b0110 sltu 4’b0111 addi 12345678910111213141516wire [32:0] A_ext = {A[31],A};wire [32:0] B_ext = {B[31],B};wire [32:0] temp = A_ext + B_ext; always @(*) begin case(F) `ADD: C = A + B; `ADDI: C = (temp[32] == temp[31])?temp[31:0]:32'd0; `SUB: C = A - B; `OR: C = A | B; `SL16: C = B &lt;&lt; 16; `AND: C = A &amp; B; `SLT: C = ($signed(A) &lt; $signed(B))? 32'b1: 32'b0; `SLTU: C = (A &lt; B)? 32'b1: 32'b0; default:C = 0; endcase mdOp (4-bit) mdOp type 4’b0001 mult 4’b0010 multu 4’b0011 div 4’b0100 divu 4’b0101 mthi 4’b0110 mtlo 4’b0111 mfhi 4’b1000 mflo 123456789// in MulDivBlockalways @(*) begin case (op) 4'b0001: {prod_HI, prod_LO} = ($signed(A) * $signed(B));//mult 4'b0010: {prod_HI, prod_LO} = $unsigned(A) * $unsigned(B);//multu 4'b0011: {prod_HI, prod_LO} = {$signed(A) % $signed(B), $signed(A) / $signed(B)};//div 4'b0100: {prod_HI, prod_LO} = {A % B, A / B};//divu endcaseend 123wire [31:0] mdb_output = (mdOp_EX == 4'b0111)? mdb_HI: (mdOp_EX == 4'b1000)? mdb_LO: 32'd0; load_type (3-bit) load_type type 3’b000 lw 3’b001 lbu 3’b010 lb 3’b011 lhu 3’b100 lh 123456assign data_out = (load_type == 3'b000)? data_input: (load_type == 3'b001)? {24'b0, byte_sel}: (load_type == 3'b010)? {{24{byte_sel[7]}}, byte_sel}: (load_type == 3'b011)? {16'b0, hw_sel}: (load_type == 3'b100)? {{16{hw_sel[15]}}, hw_sel}: 32'b0; store_type (3-bit) store_type type 3’b001 sw 3’b010 sb 3’b100 sh 1234wire [3:0] byteen_MA = (store_type_MA == 3'b001)? 4'b1111: //word ((store_type_MA == 3'b010))? byte_sel://byte (store_type_MA == 3'b100)? hw_sel://half word 4'b0000; 测试方案指令分类R-type ALU型指令（Grd &lt;- Grs ? Grt）——（add、sub、or、and、slt、sltu） ALU型指令（Grd &lt;- Grt ？ shamt）——（sll、srl、sra） 跳转型指令（PC &lt;- Grs）——（jr） I-type ALU-Imm型指令（Grt &lt;- Grs ？ imm）——（ori、lui、addi、andi） Memory-Store型指令（Memory[Grs + offset] &lt;- Grt）——（sw、sb、sh） Memory-load型指令（Grt &lt;- Memory[Grs + offset]）——（lw、lb、lbu、lh） Branch型指令（Grs ? Grt，PC &lt;- PC + 4 + offset）——（beq、bgez、bgtz、blez、bltz、bne） J-type J-link型指令 —— (jal) 无条件Jump型指令 IF级 ID级 EX级 MA级 WB级 R-ALU 读取数据（Grs、Grt） 计算数据 写入数据 R-jump 读取数据并跳转 I-imm 读取数据（Grt、imm） 计算数据 写入数据 I-store 读取数据（Grs+offset、Grt） 计算数据（地址） 写入数据 I-load 读取数据（Grs+offset、Grt） 计算数据（地址） 读取数据 写入数据 I-branch 读取数据（Grs、Grt）比较数据并跳转 J-link 扩展数据并跳转 传递跳转PC 传递跳转PC 写入pc+8 测试步骤 编写测试代码 包括所有阻塞情况 测试所有转发通路 可利用课程组提供的分析工具对代码测试强度进行评估 将ISE输出与Mars输出比对 可利用同学开发评测机进行快速比对 大量随机数据强测 代码生成来自学长博客 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168import randomlist_R = [&quot;addu&quot;, &quot;subu&quot;, &quot;and&quot;, &quot;or&quot;, &quot;nor&quot;, &quot;xor&quot;, &quot;sltu&quot;, &quot;slt&quot;, &quot;sllv&quot;, &quot;srlv&quot;, &quot;srav&quot;]list_I = [&quot;andi&quot;, &quot;addiu&quot;, &quot;ori&quot;, &quot;xori&quot;, &quot;lui&quot;, &quot;slti&quot;, &quot;sltiu&quot;]list_LS = [&quot;lw&quot;, &quot;sw&quot;, &quot;lh&quot;, &quot;lhu&quot;, &quot;sh&quot;, &quot;lb&quot;, &quot;lbu&quot;, &quot;sb&quot;]list_shift = [&quot;sll&quot;, &quot;srl&quot;, &quot;sra&quot;]list_B = [&quot;bne&quot;, &quot;beq&quot;,&quot;bgtz&quot;, &quot;blez&quot;, &quot;bltz&quot;, &quot;bgez&quot;]list_MD = [&quot;mult&quot;, &quot;multu&quot;, &quot;div&quot;, &quot;divu&quot;]list_MTMF = [&quot;mfhi&quot;, &quot;mflo&quot;, &quot;mthi&quot;, &quot;mtlo&quot;]#length是生成的指令所用到的寄存器个数length = 8 #为了增大冒险概率，我们将寄存器的范围缩小到0~7def R_test(file, n): for i in range(n): k = random.randint(0, 10000000) % len(list_R) rs = random.randint(0, 10000000) % length; rt = random.randint(0, 10000000) % length; rd = random.randint(0, 10000000) % length; s = &quot;{} ${}, ${}, ${}\\n&quot;.format(list_R[k], rd, rs, rt) file.write(s)def I_test(file, n): for i in range(n): k = random.randint(0, 10000000) % len(list_I) rs = random.randint(0, 10000000) % length rt = random.randint(0, 10000000) % length imm = random.randint(-32768, 32768) abs_imm = random.randint(0, 65536) if list_I[k] == &quot;lui&quot;: s = &quot;{} ${},{}\\n&quot;.format(list_I[k], rt, abs_imm) else: s = &quot;{} ${}, ${}, {}\\n&quot;.format(list_I[k], rt, rs, imm) file.write(s)def LS_test(file, n): for i in range(n): k = random.randint(0,10000000) % len(list_LS) ins = list_LS[k] num = 0 if(ins[1] == &quot;w&quot;): num = (random.randint(0,10000000) &lt;&lt; 2) % 4096 elif(ins[1] == &quot;h&quot;): num = (random.randint(0,10000000) &lt;&lt; 1) % 4096 else: num = (random.randint(0,10000000)) % 4096 rt = random.randint(0, 10000000) % length s = &quot;{} ${}, {}($0)\\n&quot;.format(ins, rt, num) file.write(s)def shift_test(file, n): for i in range(n): k = random.randint(0,10000000) % len(list_shift) shamt = random.randint(0, 10000000) % length rd = random.randint(0, 10000000) % length rt = random.randint(0, 10000000) % length s = &quot;{} ${}, ${}, {}\\n&quot;.format(list_shift[k], rd, rt, shamt) file.write(s)def MD_test(file, n): for i in range(n): k = random.randint(0,10000000) % len(list_MD) rs = random.randint(0, 10000000) % length rt = random.randint(0, 10000000) % length if(list_MD[k] == &quot;mult&quot; or list_MD[k] == &quot;mul&quot;): s = &quot;{} ${}, ${}\\n&quot;.format(list_MD[k], rs, rt) else: s = &quot;{} ${}, ${}\\n&quot;.format(list_MD[k], rs, 8) file.write(s)def MTMF_test(file, n): for i in range(n): k = random.randint(0,10000000) % len(list_MTMF) rs = random.randint(0, 10000000) % length s = &quot;{} ${}\\n&quot;.format(list_MTMF[k], rs) file.write(s)def B_test(file, lable): k = random.randint(0,10000000) % len(list_B) if(k == 0 or k == 1): rs = random.randint(0, 10000000) % length rt = random.randint(0, 10000000) % length s = &quot;{} ${}, ${}, {}\\n&quot;.format(list_B[k], rs, rt, lable) file.write(s) else: rs = random.randint(0, 10000000) % length s = &quot;{} ${}, {}\\n&quot;.format(list_B[k], rs, str(lable)) file.write(s)def b_begin(file, n): file.write(&quot;\\nb_test_{}_one:\\n&quot;.format(n)) B_test(file, &quot;b_test_{}_one_then&quot;.format(n)) R_test(file,1) file.write(&quot;b_test_{}_two:\\n&quot;.format(n)) B_test(file, &quot;b_test_{}_two_then&quot;.format(n)) I_test(file,1) file.write(&quot;jal_test_{}:\\n&quot;.format(n)) file.write(&quot;jal jal_test_{}_then\\n&quot;.format(n)) I_test(file,1) file.write(&quot;end_{}:\\n\\n&quot;.format(n)) R_test(file, 1) I_test(file, 1) LS_test(file, 1) shift_test(file, 1)def b_end(file, n): file.write(&quot;\\nb_test_{}_one_then:\\n&quot;.format(n)) R_test(file, 1) I_test(file, 1) LS_test(file, 1) shift_test(file, 1) MD_test(file, 1) MTMF_test(file, 1) file.write(&quot;j b_test_{}_two\\n&quot;.format(n)) R_test(file, 1) file.write(&quot;\\nb_test_{}_two_then:\\n&quot;.format(n)) R_test(file, 1) I_test(file, 1) LS_test(file, 1) shift_test(file, 1) MD_test(file, 1) MTMF_test(file, 1) file.write(&quot;jal jal_test_{}\\n&quot;.format(n)) file.write(&quot;addu $1, $ra, $0\\n&quot;) file.write(&quot;\\njal_test_{}_then:\\n&quot;.format(n)) R_test(file, 1) I_test(file, 1) LS_test(file, 1) shift_test(file, 1) MD_test(file, 1) MTMF_test(file, 1) file.write(&quot;addiu $ra,$ra, 8\\n&quot;.format(n)) B_test(file, &quot;end_{}&quot;.format(n)) R_test(file, 1) I_test(file, 1) LS_test(file, 1) shift_test(file, 1) MD_test(file, 1) MTMF_test(file, 1) file.write(&quot;jr $ra\\n&quot;.format(n))with open(&quot;mips_code.asm&quot;, &quot;w&quot;) as file: for i in range(length): temp = random.randint(-2147483648, 2147483648) s = &quot;li ${} {}\\n&quot;.format(i, temp) file.write(s) file.write(&quot;li $8, {}\\n&quot;.format(random.randint(-2147483648, 2147483648) % 10000 + 1)) for i in range(10): R_test(file, 2) MD_test(file,1) MTMF_test(file, 1) I_test(file, 2) LS_test(file, 2) MTMF_test(file, 1) I_test(file, 2) shift_test(file, 2) file.write(&quot;\\n&quot;) 思考题 为什么需要有单独的乘除法部件而不是整合进 ALU？为何需要有独立的 HI、LO 寄存器？ [!ANS]因为乘除操作较为复杂，需要多个周期才能完成，需要单独处理 真实的流水线 CPU 是如何使用实现乘除法的？请查阅相关资料进行简单说明。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758`define size 8 module mul_booth_signed( input wire [`size - 1 : 0] mul1,mul2, input clk, input wire [2:0] clk_cnt,//运算节拍，相当于状态机了，8位的话每次运算有4个拍 output wire [2*`size - 1 : 0] res ); //由于传值默认就是补码，所以只需要再计算“负补码”即可 wire [`size - 1 : 0] bmul1,bmul2; assign bmul1 = (~mul1 + 1'b1) ; assign bmul2 = (~mul2 + 1'b1) ;//其实乘数2的负补码也没用到。 //其实可以把状态机的开始和结束状态都写出来，我懒得写了，同学们可以尝试一下啊~ parameter zeroone = 3'b00, twothree = 3'b001, fourfive = 3'b010, sixseven = 3'b011; //y(i-1),y(i),y(i+1)三个数的判断寄存器，由于有多种情况，也可以看成状态机（也可以改写成状态机形式，大家自己试试吧） reg [2:0] temp; //部分积 reg [2*`size-1 : 0] A; //每个节拍下把相应位置的数据传给temp寄存器 always @ (posedge clk) begin case(clk_cnt) zeroone : temp &lt;= {mul2[1:0],1'b0}; twothree : temp &lt;= mul2[3:1]; fourfive : temp &lt;= mul2[5:3]; sixseven : temp &lt;= mul2[7:5]; default : temp &lt;= 0; endcase end always @(posedge clk) begin if (clk_cnt == 3'b100) begin//如果节拍到4就让部分积归0，此时已经完成一次计算了 A &lt;= 0; end else case (temp) 3'b000,3'b111 : begin//这些是从高位到低位的判断，别看反了噢 A &lt;= A + 0; end 3'b001,3'b010 : begin//加法操作使用补码即可，倍数利用左移解决 A &lt;= A + ({{8{mul1[`size-1]}},mul1} &lt;&lt; 2*(clk_cnt-1)); end 3'b011 : begin A &lt;= A + ({{8{mul1[`size-1]}},mul1} &lt;&lt; 2*(clk_cnt-1) + 1); end 3'b100: begin//减法操作利用“负补码”改成加法操作，倍数利用左移解决 A &lt;= A + ({{8{bmul1[`size-1]}},bmul1} &lt;&lt; 2*(clk_cnt-1) + 1); end 3'b101,3'b110 : begin A &lt;= A + ({{8{bmul1[`size-1]}},bmul1} &lt;&lt; 2*(clk_cnt-1)); end default: A &lt;= 0; endcase end //当节拍到4的时候写入结果寄存器。 assign res = (clk_cnt == 3'b100) ? A : 0; endmodule 请结合自己的实现分析，你是如何处理 Busy 信号带来的周期阻塞的？ [!ANS]修改P5中的Stall逻辑，当乘除槽处于start或busy状态，且ID级指令需要使用乘除槽时阻塞 12wire Stall_md = ((busy | start) &amp; (mult_ID | multu_ID | div_ID | divu_ID | mfhi_ID | mflo_ID | mthi_ID | mtlo_ID));assign Stall = Stall_RS_EX | Stall_RS_MA | Stall_RT_EX | Stall_RT_MA | Stall_md; 请问采用字节使能信号的方式处理写指令有什么好处？（提示：从清晰性、统一性等角度考虑） [!ANS]更符合实际CPU电路，在实际电路中这样做更加高效。对于外部存储单元，其只需要读取使能信号然后进行相应存储即可，无需增加其他存储逻辑，使外部设备有较为统一的存储逻辑，便于扩展。 请思考，我们在按字节读和按字节写时，实际从 DM 获得的数据和向 DM 写入的数据是否是一字节？在什么情况下我们按字节读和按字节写的效率会高于按字读和按字写呢？ [!ANS]不是一字节。当存储容量较小时按字节读和写会更加高效, 不需要添加多余的逻辑。 为了对抗复杂性你采取了哪些抽象和规范手段？这些手段在译码和处理数据冲突的时候有什么样的特点与帮助？ [!ANS] 在高层模块的排布中就屏蔽了实现的细节，只保留了此模块的端口，以及端口的功能。 对于同一类型的指令增加多位宽type信号，功能模块根据不同type信号执行对应操作。例如：涉及乘除槽的指令，我设置一个mdOp信号来区分指令，从而减少了流水寄存器的接口数目，从而降低复杂度。 是否阻塞全部放到冲突处理模块判断，尽可能遵循“高内聚低耦合”的原则。 乘除槽与ALU分离，但是输出路径一致。不需要更改转发逻辑。 在本实验中你遇到了哪些不同指令类型组合产生的冲突？你又是如何解决的？相应的测试样例是什么样的？ [!ANS]涉及到HI和LO寄存器的指令与其他读写寄存器指令冲突。通过设置合理的阻塞逻辑解决。 123ori $2, $0, 128lw $3, 0($0)mult $3, $2 如果你是手动构造的样例，请说明构造策略，说明你的测试程序如何保证覆盖了所有需要测试的情况；如果你是完全随机生成的测试样例，请思考完全随机的测试程序有何不足之处；如果你在生成测试样例时采用了特殊的策略，比如构造连续数据冒险序列，请你描述一下你使用的策略如何结合了随机性达到强测的效果。 [!ANS]我才用的方案是手动构造样例确保新指令的功能正确性，随机生成指令强测确保转发和阻塞的正确性。限制读写寄存器的范围，能够尽可能多的造成数据冒险，再加上大量随机数据，基本可以覆盖全部转发和阻塞情况。 [P5、P6 选做] 请评估我们给出的覆盖率分析模型的合理性，如有更好的方案，可一并提出。","link":"/2024/12/20/P6-%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3/"},{"title":"CO-P7-设计文档","text":"2024计算机组成原理P7设计文档 P7_MIPS微系统预备知识异常程序处理先要明白一点，Mars不会帮你处理中断异常，Mars遇到异常指令或中断信号会跳至中断异常处理程序（0x4180之后），如何处理中断异常完全由0x4180之后的代码决定。 先看课程组给出的示例程序 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576# 程序首先从这里运行.text # 只允许外部中断 ori $t0, $0, 0x1001 mtc0 $t0, $12 # 算术溢出 lui $t0, 0x7fff lui $t1, 0x7fff add $t2, $t0, $t1end: beq $0, $0, end nop.ktext 0x4180_entry: # 保存上下文 j _save_context nop_main_handler: # 取出 ExcCode mfc0 $k0, $13 ori $k1, $0, 0x7c and $k0, $k0, $k1 # 如果是中断，直接恢复上下文 beq $k0, $0, _restore_context nop # 将 EPC + 4，即处理异常的方法就是跳过当前指令 mfc0 $k0, $14 addu $k0, $k0, 4 mtc0 $k0, $14 j _restore_context nop_exception_return: eret_save_context: ori $k0, $0, 0x1000 # 在栈上找一块空间保存现场 addiu $k0, $k0, -256 sw $sp, 116($k0) # 最先保存栈指针 move $sp, $k0 # 依次保存通用寄存器（注意要跳过 $sp）、HI 和 LO sw $1, 4($sp) sw $2, 8($sp) # ...... sw $31, 124($sp) mfhi $k0 mflo $k1 sw $k0, 128($sp) sw $k1, 132($sp) j _main_handler nop_restore_context: # 依次恢复通用寄存器（注意要跳过 $sp）、 HI 和 LO lw $1, 4($sp) lw $2, 8($sp) # ...... lw $31, 124($sp) lw $k0, 128($sp) lw $k1, 132($sp) mthi $k0 mtlo $k1 # 最后恢复栈指针 lw $sp, 116($sp) j _exception_return nop 代码解释 .text: Subsequent items (instructions) stored in Text segment at next available address.随后的条目（指令）存储在文本段的下一个可用地址中。普通的用户模式下的代码段，简单来说就是存指令的地方。 .ktext: Subsequent items stored in Kernel Text segment at next available address.随后的条目存储在内核文本段的下一个可用地址中。即内核模式下的代码段，内核模式下运行，具有最高权限，可以直接访问硬件和受保护的资源。对于p7来说就是存放异常处理程序的地方。 异常包括很多种类型，中断和异常也不同，不同的异常或中断处理方式不一样，因此我们需要记录下异常或中断的信息，然后用特定方式处理异常，这就是CP0（协处理器）的作用。 进入中断异常处理程序后，我们先从CP0中获取异常或中断信息，然后跳转至不同的地方处理异常中断，一般最后都会跳转到eret，返回主程序。 CPU与外设的交互CPU的作用就是对外界输入数据做出对应的处理后返回结果。 外设对于p7，我们有三个外设需要处理。这三个外设的作用就是时不时向cpu发出一个中断信号。 计时器（Timer）：计算机系统中的计时部件，可以按照配置定时地产生时钟中断。 存储器（Memory）：计算机系统中的存储部件，用于存储指令和数据。我们在 P6 的时候已经接触过了。 中断发生器（InterruptGenerator）：抽象的计算机系统外设，会随机的产生外部中断信号，产生的中断信号在 CPU 响应前会持续置高。 内存 我们可以认为内存也是一种外设。 我们可以认为指令、数据、异常处理程序、外设寄存器等都是储存在同一内存中，只不过存储的位置不同，有着严格的界限。 条目 地址或地址范围 备注 数据存储器 0x0000_0000∼0x0000_2FFF 指令存储器 *** 0x0000_3000∼0x0000_6FFF*** PC 初始值 0x0000_3000 异常处理程序入口地址 0x0000_4180 计时器 0 寄存器地址 0x0000_7F00∼0x0000_7F0B 计时器 0 的 3 个寄存器 计时器 1 寄存器地址 0x0000_7F10∼0x0000_7F1B 计时器 1 的 3 个寄存器 中断发生器响应地址 0x0000_7F20∼0x0000_7F23 宏观PC对于流水线寄存器，每一流水级的PC都不同。我们希望CPU实现的功能应该是单周期的，引入多周期只是为了提高效率。如果我们把CPU封装起来，不关注内部的复杂过程，在外部看来CPU应该只有一个PC，即CPU一个周期仅执行一条指令。为此我们需要引入宏观PC的概念。 我们将 CP0 放在 M 级（大家都放在M级，方便对拍），因此也以 M 级为界线，规定 M 级的 PC 就是宏观 PC。 所谓“宏观”指令，表示该指令之前的所有指令序列对 CPU 的更新已完成，该指令及其之后的指令序列对 CPU 的更新未完成。放在M级显然满足这个定义。 TasksTask-1: 建立与外界的联系Timer Timer内部有三个寄存器: 0号寄存器ctrl、1号寄存器preset、2号寄存器count。虽然说是寄存器，但我们可以认为其实内存的一部分。 0号寄存器ctrl 1号寄存器preset 2号寄存器count TC1 0x0000_7F00∼0x0000_7F03 0x0000_7F04∼0x0000_7F07 0x0000_7F08∼0x0000_7F0b TC2 0x0000_7F10∼0x0000_7F13 0x0000_7F14∼0x0000_7F17 0x0000_7F18∼0x0000_7F1b 我们可以通过sw指令向对应Timer寄存器中存值以开启计时并调整倒计时。 1234567891011# MODE 0 for timer1ori $t1 $0 9 #设置计时使能和中断屏蔽sw $t1 0x7F00($0)ori $t1 $0 1 #设置计时数sw $t1 0x7F04($0)# MODE 1 for timer1ori $t1 $0 11 #设置计时使能和中断屏蔽sw $t1 0x7F00($0)ori $t1 $0 10 #设置计时数sw $t1 0x7F04($0) Task-2: 记录异常并流水 where CP0: M级。 延迟槽指令: 如果一个处于延迟槽的指令发生了异常，我们从异常处理程序中返回时需要回到它的上一个指令（跳转指令）。因此我们需要增加判断一个信号用于判断指令是否在延迟槽中，并向后流水传至CP0。（branch、jump、jal、jr在ID级，IF级的指令即处于延迟槽中）。 12assign BD_IF = ((branch_ID === 1'b1) || (jump_ID === 1'b1))? 1'b1: 1'b0; 内部异常和外部中断：同时发生时处理外部中断，当内部无异常时设为Int(外部中断)。 一条指令多个异常 &amp; 多个指令异常：优先处理最早可以探查到的异常。 异常与中断码 助记符与名称 指令与指令类型 描述 0 Int （外部中断） 所有指令 中断请求，来源于计时器与外部中断。 4 AdEL （取指异常） 所有指令 PC 地址未字对齐。 1 4 AdEL （取指异常） 所有指令 PC 地址超过 0x3000 ~ 0x6ffc。 1 4 AdEL （取数异常） lw 取数地址未与 4 字节对齐。 1 4 AdEL （取数异常） lh 取数地址未与 2 字节对齐。 1 4 AdEL （取数异常） lh, lb 取 Timer 寄存器的值。 4 AdEL （取数异常） load 型指令 计算地址时加法溢出。 1 4 AdEL （取数异常） load 型指令 取数地址超出 DM、Timer0、Timer1、中断发生器的范围。 5 AdES （存数异常） sw 存数地址未 4 字节对齐。 1 5 AdES （存数异常） sh 存数地址未 2 字节对齐。 1 5 AdES （存数异常） sh, sb 存 Timer 寄存器的值。 5 AdES （存数异常） store 型指令 计算地址加法溢出。 1 5 AdES （存数异常） store 型指令 向计时器的 Count 寄存器存值。 5 AdES （存数异常） store 型指令 存数地址超出 DM、Timer0、Timer1、中断发生器的范围。 8 Syscall （系统调用） syscall 系统调用。 10 RI（未知指令） - 未知的指令码。 12 Ov（溢出异常） add, addi, sub 算术溢出。 1 IF级 PC 地址未字对齐 AdEL PC 地址超过 0x3000 ~ 0x6ffc AdEL 123// in PC moduleassign exc = ((pc &lt; 32'h3000) || (pc &gt; 32'h6ffc))? 4'd4: (pc[1:0] != 2'b0)? 4'd4: 4'd0; ID级 未知的指令码 RI syscall 对于syscall指令我们只需发出一个异常信号即可 syscall 如果有if嵌套，注意内部if对应的else也需要判断为未知指令。 1234567891011121314151617// in controller moduleif (OpCode == xxxxxx) begin if (Funct == xxxxxx) begin //ctrl signal assignment end else begin //exception RI exc = 4'd10; endendelse if (OpCode == xxxxxx) begin //ctrl signal assignment endelse begin //exception RI exc = 4'd10; end EX级 算术溢出 OV 12345678910111213wire [32:0] A_ext = {A[31],A};wire [32:0] B_ext = {B[31],B};wire [32:0] addi_temp = A_ext + B_ext;wire addi_overflow = ((F == `ADDI) &amp;&amp; (addi_temp[32] != addi_temp[31]));wire [32:0] add_temp = A_ext + B_ext;wire add_overflow = ((F == `ADD) &amp;&amp; (add_temp[32] != add_temp[31]));wire [32:0] sub_temp = A_ext - B_ext;wire sub_overflow = ((F == `SUB) &amp;&amp; (sub_temp[32] != sub_temp[31]));assign exc = (addi_overflow | add_overflow | sub_overflow)? 4'd12: 4'd0; MA级 load类指令 lw取数地址未与 4 字节对齐 AdEL lh、lb取数地址未与 2 字节对齐 AdEL lh、lb取 Timer 寄存器的值：寄存器的值为32位，取半字或比特是非法行为非法 AdEL 计算地址时加法溢出 AdEL 取数地址超出 DM、Timer0、Timer1、中断发生器的范围 AdEL store类指令 sw存数地址未 4 字节对齐 AdES sh、sb存数地址未 2 字节对齐 AdES sh、sb存 Timer 寄存器的值 ：寄存器的值为32位，存半字或比特是非法行为非法 AdES 计算地址加法溢出 AdES 向计时器的 Count 寄存器存值 ：计时器的count寄存器是只读寄存器(read-only) AdES 存数地址超出 DM、Timer0、Timer1、中断发生器的范围 AdES 123456789101112131415161718192021222324252627282930313233//load EXCwire exc_load_align = (((load_type_MA == 3'b111) &amp;&amp; (byte_offset != 2'b00)) || //lw ((load_type_MA == 3'b100) &amp;&amp; (byte_offset[0] != 1'b0))); //lhwire exc_load_adov = (load_type_MA &amp;&amp; (EX_EXCCode_pip_MA == 4'd12));wire exc_load_OutOfRange = !(((ALU_C_MA &gt;= 32'h0) &amp;&amp; (ALU_C_MA &lt;= 32'h2fff)) || //DM ((ALU_C_MA &gt;= 32'h7f00) &amp;&amp; (ALU_C_MA &lt;= 32'h7f0b)) || //TC0 ((ALU_C_MA &gt;= 32'h7f10) &amp;&amp; (ALU_C_MA &lt;= 32'h7f1b))); //TC1wire exc_load_timer = ((load_type_MA == 3'b100 || load_type_MA == 3'b010) &amp;&amp; ALU_C_MA &gt;= 32'h7f00); wire EXCCode_ADEL = (load_type_MA) &amp;&amp; (exc_load_align || exc_load_adov || exc_load_OutOfRange || exc_load_timer);//store EXCwire exc_store_align = (((store_type_MA == 3'b001) &amp;&amp; (byte_offset != 2'b00)) || ((store_type_MA == 3'b100) &amp;&amp; (byte_offset[0] != 1'b0))); wire exc_store_adov = (store_type_MA &amp;&amp; (EX_EXCCode_pip_MA == 4'd12)); //addr overflowwire exc_store_OutOfRange = !(((ALU_C_MA &gt;= 32'h0) &amp;&amp; (ALU_C_MA &lt;= 32'h2fff)) || //DM ((ALU_C_MA &gt;= 32'h7f00) &amp;&amp; (ALU_C_MA &lt;= 32'h7f0b)) || //TC0 ((ALU_C_MA &gt;= 32'h7f10) &amp;&amp; (ALU_C_MA &lt;= 32'h7f1b))); //TC1wire exc_store_timer = (store_type_MA &amp;&amp; ALU_C_MA &gt;= 32'h0000_7f08 &amp;&amp; ALU_C_MA &lt;= 32'h0000_7f0b) || (store_type_MA &amp;&amp; ALU_C_MA &gt;= 32'h0000_7f18 &amp;&amp; ALU_C_MA &lt;= 32'h0000_7f1b) || ((store_type_MA == 3'b010 || store_type_MA == 3'b100) &amp;&amp; ALU_C_MA &gt;= 32'h7f00); wire EXCCode_ADES = (store_type_MA) &amp;&amp; (exc_store_align || exc_store_adov || exc_store_OutOfRange || exc_store_timer);assign MA_EXCCode_pip_MA = EXCCode_ADEL? 4'd4: EXCCode_ADES? 4'd5: 4'd0; Task-3: 加入协处理器CP0 所有寄存器均为32bits 处理中断和异常信号，判断是否发出req信号，发出req信号时所有流水寄存器清空（部分信号需要特殊处理） eret指令需要清空EXL部分 0001_0000 寄存器 寄存器编号 功能域 位域 解释 SR（State Register） 12 IM（Interrupt Mask） 15:10 分别对应六个外部中断，相应位置 1 表示允许中断，置 0 表示禁止中断。这是一个被动的功能，只能通过 mtc0 这个指令修改，通过修改这个功能域，我们可以屏蔽一些中断。 SR（State Register） 12 EXL（Exception Level） 1 任何异常发生时置位，这会强制进入核心态（也就是进入异常处理程序）并禁止中断。 SR（State Register） 12 IE（Interrupt Enable） 0 全局中断使能，该位置 1 表示允许中断，置 0 表示禁止中断。 Cause 13 BD（Branch Delay） 31 当该位置 1 的时候，EPC 指向当前指令的前一条指令（一定为跳转），否则指向当前指令。 Cause 13 IP（Interrupt Pending） 15:10 为 6 位待决的中断位，分别对应 6 个外部中断，相应位置 1 表示有中断，置 0 表示无中断，将会每个周期被修改一次，修改的内容来自计时器和外部中断。 Cause 13 ExcCode 6:2 异常编码，记录当前发生的是什么异常。 EPC 14 - - 记录异常处理结束后需要返回的 PC。 端口 方向 位数 解释 clk IN 1 时钟信号。 reset IN 1 复位信号。 en IN 1 写使能信号。 CP0Add IN 5 读取/写入目标寄存器地址。 CP0In IN 32 写入寄存器数据。 CP0Out OUT 32 读出寄存器数据。 VPC IN 32 当前异常中断发生时PC的值。 BDIn IN 1 当前异常中断发生指令是否是延迟槽内指令。 ExcCodeIn IN 5 当前发生异常类型。 HWInt IN 6 外部产生的中断信号。 EXLClr IN 1 是否结束异常中断处理（复位 EXL）。 EPCOut OUT 32 EPC 的值。 Req OUT 1 进入处理程序请求。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849`define IM regs[12][15:10]`define EXL regs[12][1]`define IE regs[12][0]`define BD regs[13][31]`define IP regs[13][15:10]`define EXCCode regs[13][6:2] // SR-12, Cause-13, EPC-14 reg [31:0] regs [0:31]; assign CP0Out = regs[CP0Addr]; wire IntReq = (|(HWInt &amp; `IM)) &amp; !`EXL &amp; `IE; // 允许当前中断 且 不在中断异常中 且 允许中断发生 wire ExcReq = (|EXCCodeIn) &amp; !`EXL; // 存在异常 且 不在中断中 assign Req = IntReq | ExcReq; wire [31:0] tempEPC = (Req) ? (BDIn ? VPC-4 : VPC) : regs[14]; assign EPCOut = {tempEPC[31:2], 2'b0}; integer i; initial begin for (i=0;i&lt;32;i=i+1) begin regs[i] = 0; end end always @(posedge clk) begin if (reset) begin for (i=0;i&lt;32;i=i+1) begin regs[i] &lt;= 0; end end else begin `IP &lt;= HWInt; if (en) begin regs[CP0Addr] &lt;= CP0In; end if (Req) begin // int|exc `EXCCode &lt;= IntReq ? 5'b0 : EXCCodeIn; `EXL &lt;= 1'b1; regs[14] &lt;= tempEPC; `BD &lt;= BDIn; end if (EXLClr) begin `EXL &lt;= 1'b0; end end end Task-4: 加指令在 P6 基础上新增了 mfc0, mtc0, eret, syscall 四条新指令 目前p7要求实现如下指令：(最好把jump指令也实现了，方便处理异常) 123456nop, add, sub, and, or, slt, sltu, luiaddi, andi, orilb, lh, lw, sb, sh, swmult, multu, div, divu, mfhi, mflo, mthi, mtlobeq, bne, jal, jr,mfc0, mtc0, eret, syscall MFC0把CP0中的rd号寄存器的值存入grf的rt寄存器 需要简单处理下转发，类似lw的转发 MTC0将grf的rt号寄存器的值存入CP0的rd号寄存器 ERET从错误处理程序中返回到主程序 在ID级时设置next_pc为CP0的EXC 在ID级时清空延迟槽，确保后续指令不会被处理 到达MA级时，需要清空CP0的EXL部分，表示当前不在处于核心状态（异常处理程序） 在ID级时，如果EX或MA级是MTC0且目标寄存器为14号（EXC）则阻塞，确保返回地址正确。 syscall在controller里发出一个异常信号（异常码为8）即可 流水寄存器行为为什么要修改寄存器的清空行为？我们在阻塞的时候会在EX级产生一个bubble，可以看作nop不发生任何作用，但实际上我们要把CPU封装为单周期CPU，级两条相邻的指令之间不会莫名其妙多出来一个nop指令。 试想，如果不修改清空逻辑的情况下，ID级是一个延迟槽内的指令，正常来说它到达MA级时如果发生了异常或中断，我们的EPC是需要写入PC-4的，因为我们从异常处理程序中返回时需要返回到延迟槽指令的前一条指令（即跳转指令）。而如果延迟槽内的指令在ID级时发生了阻塞产生了一个’nop’，nop流水到MA级时发生了异常或中断我们该如何记录EPC？这个’nop’在外部看来是不应该存在的，其没有对应的PC，其对应的PC应该是延迟槽指令的PC，其也应该被标记为延迟槽内指令，这样从异常处理程序中返回时才能返回到正确的地址。 按照从上至下的优先级依次处理 信号 PC流水寄存器行为 BD流水寄存器行为 其他流水寄存器行为 reset 复位至 0x00003000 复位至 0 清空 req 设置为 0x00004180 设置为 0 清空 ID_EXLClr （仅对F级到D级流水寄存器起作用，且此时stall信号为0） 设置为当前周期的 EPC 的值 不发生变化 清空 flush（仅指对D级到E级流水寄存器起作用的阻塞信号） 不发生变化 不发生变化 清空 PC12345678910always @(posedge clk) begin if (reset || req) begin pc &lt;= req? 32'h4180: 32'h3000; end else begin if (en) begin pc &lt;= next_pc; end endend IF_ID Regclear_bd表示清空延迟槽，对于P7仅针对eret指令 1234567891011121314always @(posedge clk) beginif (reset || clr || req || clear_bd) begin //置0操作省略 pc_add4_out &lt;= (reset)? 32'h00003004: (req)? 32'h00004184: (clear_bd)? EPC: 0; BD_out &lt;= (clear_bd)? BD: 0;end else begin if (en) begin //省略 endendend ID_EX Reg123456789101112131415always @(posedge clk) beginif (reset || stall || req) begin //置0操作省略 pc_add4_out &lt;= (reset)? 32'h00003004: (req)? 32'h00004184: (stall)? pc_add4: 0; BD_out &lt;= (stall)? BD: 0;endelse begin if (en) begin //省略 endendend EX_MA Reg123456789101112always @(posedge clk) begin if (reset || clr || req) begin //置0操作省略 pc_add4_out &lt;= reset? 32'h00003004: req? 32'h00004184: 0; end else begin if (en) begin //省略 end endend MA_WB Reg1234567891011always @(posedge clk) begin if (clr || reset || req) begin //置0操作省略 pc_add4_out &lt;= reset? 32'h00003004: req? 32'h00004184: 0; end else begin if (en) begin //省略 end end 我的Bug以下是我在通过课下弱测和中测后发现的bug： 不涉及计算操作时ALUOP默认设为了`ADD，导致不是ALU类指令时出现了溢出情况。 当MA级异常时，如果EX级为mthi或mtlo时仍会向HI或LO中写入值。 当PC错误或遇到未知指令时没有向后传递nop。 mtc0位于MA级时，如果当出现中断时，仍会向CP0中的寄存器写入值。 EXCCode优先级问题。load或store指令会触发EX级的算术overflow（异常码12）异常，在MA级也会除法overflow（异常码4或5）的异常，按照优先处理先探查到的错误的原则我们会选择EX级的算术overflow，导致存入CP0的异常码错误。 测试方案 手动构造样例确保新指令的功能正确性，尽可能覆盖大部分异常情况。 随机生成指令强测确保转发和阻塞的正确性。对CO-Killer略加修改，生成符合要求的随机数据。 限制读写寄存器的范围，能够尽可能多的造成数据冒险，再加上大量随机数据，基本可以覆盖全部转发和阻塞情况。 利用自己写的python脚本填充nop至0x4180。 定时器产生周期性中断信号，测试timer的中断是否正确被处理。 修改testbench产生中断，测试中断发生器发出的中断是否正确被处理。 123456# 填充noplast_pc = input('enter the last pc in text: ')pc = int(last_pc, 16) + 4while pc &lt; 0x4180: print(f&quot;# {hex(pc)}\\nnop&quot;) pc += 4 思考题 请查阅相关资料，说明鼠标和键盘的输入信号是如何被 CPU 知晓的？ 鼠标和键盘产生中断信号，进入中断处理区的对应位置，将输入信号从鼠标和键盘中读入寄存器。 请思考为什么我们的 CPU 处理中断异常必须是已经指定好的地址？如果你的 CPU 支持用户自定义入口地址，即处理中断异常的程序由用户提供，其还能提供我们所希望的功能吗？如果可以，请说明这样可能会出现什么问题？否则举例说明。（假设用户提供的中断处理程序合法） 指定好的中断处理入口地址由硬件设计决定，能确保所有中断和异常按照既定逻辑处理。如果允许用户自定义入口地址，用户可能会直接跳过关键的上下文保存步骤，导致程序状态紊乱 指定的中断地址通常位于受保护的系统区域，由操作系统或固件控制。用户故意定义有害的中断处理程序，例如窃取敏感信息或修改关键数据。 为何与外设通信需要 Bridge？ CPU与外设数据吞吐量存在差异：Bridge充当缓冲区和速率匹配器，协调高速的处理器与低速外设之间的数据交换。 地址映射差异：Bridge可以对地址进行解码，将处理器的访问请求转化为外设能够理解的操作。 请阅读官方提供的定时器源代码，阐述两种中断模式的异同，并针对每一种模式绘制状态移图。 MODE 0 定时产生中断信号 MODE 1 周期性产生中断信号 倘若中断信号流入的时候，在检测宏观 PC 的一级如果是一条空泡（你的 CPU 该级所有信息均为空）指令，此时会发生什么问题？在此例基础上请思考：在 P7 中，清空流水线产生的空泡指令应该保留原指令的哪些信息？ 如果此时有一个中断或异常信号，则CP0记录下的PC为0x0000，在从异常处理程序返回时会发生错误。 应该保留PC值，由于在Req信号有效时，通过将流水寄存器的PC值不进行复位，使得达到精确异常的效果。使得回到EPC时依然是精确的。 为什么 jalr 指令为什么不能写成 jalr $31, $31？ 如果 jalr $31 $31 的延迟槽内发生异常或需要响应中断。那么 $31 寄存器的值已经被 jalr 改变，但是处理异常结束后，会再次执行 jalr 指令，这就会跳转到不正确的 PC 地址。 [P7 选做] 请详细描述你的测试方案及测试数据构造策略。 见上文 课程组官方TestBench123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143`timescale 1ns/1psmodule mips_txt; reg clk; reg reset; reg interrupt; wire [31:0] macroscopic_pc; wire [31:0] i_inst_addr; wire [31:0] i_inst_rdata; wire [31:0] m_data_addr; wire [31:0] m_data_rdata; wire [31:0] m_data_wdata; wire [3 :0] m_data_byteen; wire [31:0] m_int_addr; wire [3 :0] m_int_byteen; wire [31:0] m_inst_addr; wire w_grf_we; wire [4 :0] w_grf_addr; wire [31:0] w_grf_wdata; wire [31:0] w_inst_addr; mips uut( .clk(clk), .reset(reset), .interrupt(interrupt), .macroscopic_pc(macroscopic_pc), .i_inst_addr(i_inst_addr), .i_inst_rdata(i_inst_rdata), .m_data_addr(m_data_addr), .m_data_rdata(m_data_rdata), .m_data_wdata(m_data_wdata), .m_data_byteen(m_data_byteen), .m_int_addr(m_int_addr), .m_int_byteen(m_int_byteen), .m_inst_addr(m_inst_addr), .w_grf_we(w_grf_we), .w_grf_addr(w_grf_addr), .w_grf_wdata(w_grf_wdata), .w_inst_addr(w_inst_addr) ); initial begin clk &lt;= 0; reset &lt;= 1; interrupt &lt;= 0; #20 reset &lt;= 0; end integer i; reg [31:0] fixed_addr; reg [31:0] fixed_wdata; reg [31:0] data[0:4095]; reg [31:0] inst[0:5119]; // ----------- For Instructions ----------- assign m_data_rdata = data[(m_data_addr &gt;&gt; 2) % 5120]; assign i_inst_rdata = inst[((i_inst_addr - 32'h3000) &gt;&gt; 2) % 5120]; initial begin $readmemh(&quot;code.txt&quot;, inst); for (i = 0; i &lt; 5120; i = i + 1) data[i] &lt;= 0; end // ----------- For Data Memory ----------- always @(*) begin fixed_wdata = data[(m_data_addr &gt;&gt; 2) &amp; 4095]; fixed_addr = m_data_addr &amp; 32'hfffffffc; if (m_data_byteen[3]) fixed_wdata[31:24] = m_data_wdata[31:24]; if (m_data_byteen[2]) fixed_wdata[23:16] = m_data_wdata[23:16]; if (m_data_byteen[1]) fixed_wdata[15: 8] = m_data_wdata[15: 8]; if (m_data_byteen[0]) fixed_wdata[7 : 0] = m_data_wdata[7 : 0]; end always @(posedge clk) begin if (reset) for (i = 0; i &lt; 4096; i = i + 1) data[i] &lt;= 0; else if (|m_data_byteen &amp;&amp; fixed_addr &gt;&gt; 2 &lt; 4096) begin data[fixed_addr &gt;&gt; 2] &lt;= fixed_wdata; $display(&quot;%d@%h: *%h &lt;= %h&quot;, $time, m_inst_addr, fixed_addr, fixed_wdata); end end // ----------- For Registers ----------- always @(posedge clk) begin if (~reset) begin if (w_grf_we &amp;&amp; (w_grf_addr != 0)) begin $display(&quot;%d@%h: $%d &lt;= %h&quot;, $time, w_inst_addr, w_grf_addr, w_grf_wdata); end end end // ----------- For Interrupt ----------- wire [31:0] fixed_macroscopic_pc; assign fixed_macroscopic_pc = macroscopic_pc &amp; 32'hfffffffc; parameter target_pc = 32'h00003010; integer count; initial begin count = 0; end always @(negedge clk) begin if (reset) begin interrupt = 0; end else begin if (interrupt) begin if (|m_int_byteen &amp;&amp; (m_int_addr &amp; 32'hfffffffc) == 32'h7f20) begin interrupt = 0; end end else if (fixed_macroscopic_pc == target_pc) begin if (count == 0) begin count = 1; interrupt = 1; end end end end always #2 clk &lt;= ~clk;endmodule","link":"/2024/12/20/P7_%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3/"}],"tags":[],"categories":[],"pages":[]}