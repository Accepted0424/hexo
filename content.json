{"posts":[{"title":"Logisim视角下的Moore与Mealy状态机辨析","text":"Moore与Mealy辨析 Logisim视角下的Moore与Mealy状态机辨析表示有限个状态以及在这些状态之间的转移和动作等行为的数学统计模型。 FSM（有限状态机）组成部分 State : 系统可能处于的状态。每个状态反映的是系统的某个模式或环节。有限状态机的状态是有限的。 Input : 外部输入的信号，会影响状态的转换。 Output : 状态机在特定条件下输出的信号。 Transitions : 系统根据状态转移函数从一个状态转移到另一个状态。 Initial State : 系统的初始状态。 例题（字符串匹配）在了解有限状态机的两种类型前，我们先来看一道例题（选自BUAA_CO_P0） 使用Logisim搭建一个有限状态机检测串行输入字符串中的能匹配正则表达式b{1,2}[ac]{2}的子串并输出。即我们要得到这样一个字符串：开头有一个或两个b，接着要出现两次a/c。 注意：每当匹配到一个子串时，需要输出一次1。例如对字符串bacbacac,模块应当在第1个c输入和第2个c输入时输出1,而在其他时刻保持输出为0。 Moore Machine我们先通过Moore状态机来实现题目要求。Moore状态机是有限状态机的一种，其输出仅依赖于当前状态。即只要系统处于某个特定状态，无论当前输入是什么，都会有对应的输出。 首先我们先画出状态转移图 根据上图我们可以轻松地在logisim中搭出相应的电路 $$利用真值表构建状态转移模块$$ Mealy Machine再利用Mealy状态机实现题目要求。Mealy状态机是有限状态机的另外一种，其输出结果不仅和当前状态有关，还和当前输出有关。 我们仍然是先画出状态转移图 在logisim中搭建相应电路 $$利用真值表构建状态转移模块$$由于Mealy状态机的输出Z由状态和输出共同决定，所以可以在构建真值表时直接根据状态和输入给出Z的值。 Moore &amp; Mealy下面我们通过波形图的方式分析两种有限状态机的差别。 上升沿输入一个字符，且输入在一个周期内保持不变 Moore状态机在读入字符c后状态变为11，经过判断符合置位条件，输入变为1，非常符合我们的直觉。 Mealy状态机则在读入字符a后输入就变为1，因为读入a之后状态变为10，此时输入仍为a，状态机识别到字符序列baa，符合置位条件，输入变为1，而在读入c之后状态变为00，不再符合置位条件。 下降沿输入一个字符，且输入在一个周期内保持不变 虽然是下降沿读入一个字符，但是状态机的状态在上升沿时才会更新，所以对于Moore状态机，其实就等于上一种情况滞后一个周期。 对于Mealy状态机，在状态更新为10后，输入仍为a，检测序列为baa，符合置位条件，在之后的下降沿输入变为c，此时检测序列为bac，仍符合置位条件。 异步输入 在接收到字符a后的一个周期内任意时刻输入c，Mealy状态机的输出都会立刻发生变化，而Moore状态机则需要等到下一个时钟上沿到来输出才会变化。 总结 对于本题来说，Moore状态机和Mealy状态机实现的功能有所差异。 Moore状态机同步输出，Mealy状态机异步输出。Mealy对输入的反应更快。 实现相同功能，Mealy所需要的状态数比Moore型少，Moore需要状态稳定才能输出。（对于异步输入来说，因为同步输入时结果并不相同） 并非所有时许电路都可以用Mealy状态机实现，一些时序逻辑电路只能通过Moore状态机实现。","link":"/2024/10/05/Logisim%E8%A7%86%E8%A7%92%E4%B8%8B%E7%9A%84Moore%E4%B8%8EMealy%E7%8A%B6%E6%80%81%E6%9C%BA%E8%BE%A8%E6%9E%90/"},{"title":"C语言程序设计期末总结","text":"常用知识点总结 目录 目录 常见库函数 switch用法 fgets用法 strstr用法 strcmp用法 判断字母大小写 sscan &amp; sprintf用法 取两个数中较大值或较小值 qsort用法 判断一个十进制数的二进制表示中有几个“ 1 ” 找最大公约数 二分法查找数组中目标数值的位置 位运算 1. 按位与（AND）：&amp; 2. 按位或（OR）：| 3. 按位异或（XOR）：^ 4. 按位取反（NOT）：~ 5. 左移：&lt;&lt; 6. 右移：&gt;&gt; 占位符 数据类型及范围 整型数据类型 浮点型数据类型 字符型数据类型 指针类型 数组类型 其他类型 转义符 递归函数计算阶乘 判断质数 冒泡排序 升序 降序 大小写转换函数(toupper &amp; tolower) 常见库函数 字符处理函数（在 &lt;ctype.h&gt; 头文件中） isalpha(int ch)： 检查字符是否是字母。 isdigit(int ch)： 检查字符是否是数字。 isalnum(int ch)： 检查字符是否是字母或数字。 islower(int ch)： 检查字符是否是小写字母。 isupper(int ch)： 检查字符是否是大写字母。 tolower(int ch)： 将字符转换为小写形式。 toupper(int ch)： 将字符转换为大写形式。 字符串处理函数（在 &lt;string.h&gt; 头文件中） strlen(const char *str)： 返回字符串的长度。 strcpy(char *dest, const char *src)： 将一个字符串复制到另一个字符串。 strcat(char *dest, const char *src)： 将一个字符串追加到另一个字符串。 strcmp(const char *str1, const char *str2)： 比较两个字符串。 strncmp(const char *str1, const char *str2, size_t n)： 比较两个字符串的前 n 个字符。 strchr(const char *str, int ch)： 在字符串中查找字符第一次出现的位置。 strstr(const char *haystack, const char *needle)： 在字符串中查找子字符串的第一次出现位置。 数学函数（在 &lt;math.h&gt; 头文件中） sqrt(double x)： 返回 x 的平方根。 pow(double x, double y)： 返回 x 的 y 次幂。 fabs(double x)： 返回 x 的绝对值。 ceil(double x)： 返回不小于 x 的最小整数值。 floor(double x)： 返回不大于 x 的最大整数值。 sin(double x)： 返回 x 的正弦值。 cos(double x)： 返回 x 的余弦值。 tan(double x)： 返回 x 的正切值。 输入/输出函数（在 &lt;stdio.h&gt; 头文件中） printf(const char *format, ...)： 格式化输出到标准输出。 scanf(const char *format, ...)： 格式化输入从标准输入。 fgets(char *str, int n, FILE *stream)： 从文件流中读取一行。 fputs(const char *str, FILE *stream)： 将字符串写入文件流。 fscanf(FILE *stream, const char *format, ...)： 从文件流中格式化输入。 fprintf(FILE *stream, const char *format, ...)： 将格式化输出写入文件流。 内存分配函数（在 &lt;stdlib.h&gt; 头文件中） qsort(void *base, size_t nmemb, size_t size, int (*compar)(const void *, const void *))： 对数组进行快速排序。 malloc(size_t size)： 分配指定字节数的内存。 calloc(size_t num, size_t size)： 分配指定数量和大小的内存块，并将其初始化为零。 realloc(void *ptr, size_t size)： 更改之前分配的内存块的大小。 free(void *ptr)： 释放之前分配的内存块。 这只是一小部分标准库函数。C 语言标准库提供了许多其他有用的函数，用于处理日期和时间、动态分配内存等。标准库函数的完整列表和详细信息可以在相关的 C 语言标准文档中找到。 switch用法1234567891011switch(m){ case 1: case 3: case 5: printf(&quot;yes&quot;); break; case 4:case 6: printf(&quot;no&quot;); break; default: break;} 输入数值后输入字符串 12scanf(&quot;%d\\n&quot;,&amp;n);gets(text); fgets用法 结束使用NULL而非EOF(当 fgets 遇到文件结束时，它会返回一个空指针 (NULL)) strcspn 函数返回字符串中不包含指定字符集合中任何字符的第一个位置（即字符串中不包含这些字符的部分的长度） 用scanf读取字符串时，%s在遇到空格、制表符或换行符时会停止读取。如果用户输入包含空格，只会读取第一个单词1234567fgets(myString, sizeof(myString), stdin);// 去除末尾的换行符myString[strcspn(myString, &quot;\\n&quot;)] = '\\0';// 输出处理后的字符串printf(&quot;Processed string: %s\\n&quot;, myString); strstr用法需要注意的是，strstr 是区分大小写的。如果你需要进行大小写不敏感的查找，可以考虑使用其他函数，比如 strcasestr（不是标准C函数，但在一些系统中可能提供）或手动转换字符串为小写/大写后再使用 strstr。 123456789101112131415161718#include &lt;stdio.h&gt;#include &lt;string.h&gt;int main() { const char *haystack = &quot;Hello, World!&quot;; const char *needle = &quot;World&quot;; // 在 haystack 中查找 needle char *result = strstr(haystack, needle); if (result != NULL) { printf(&quot;'%s' found at position %ld in '%s'\\n&quot;, needle, result - haystack, haystack); } else { printf(&quot;'%s' not found in '%s'\\n&quot;, needle, haystack); } return 0;} strcmp用法12345678910111213141516171819#include &lt;stdio.h&gt;#include &lt;string.h&gt;int main() { const char *str1 = &quot;apple&quot;; const char *str2 = &quot;banana&quot;; int result = strcmp(str1, str2); if (result &lt; 0) { printf(&quot;%s is less than %s\\n&quot;, str1, str2); } else if (result == 0) { printf(&quot;%s is equal to %s\\n&quot;, str1, str2); } else { printf(&quot;%s is greater than %s\\n&quot;, str1, str2); } return 0;} 判断字母大小写1234567891011121314#include &lt;stdio.h&gt;#include &lt;ctype.h&gt;int main() { char ch = 'A'; if (isupper(ch)) { printf(&quot;%c is an uppercase letter.\\n&quot;, ch); } else { printf(&quot;%c is not an uppercase letter.\\n&quot;, ch); } return 0;} 1234567891011121314#include &lt;stdio.h&gt;#include &lt;ctype.h&gt;int main() { char ch = 'a'; if (islower(ch)) { printf(&quot;%c is a lowercase letter.\\n&quot;, ch); } else { printf(&quot;%c is not a lowercase letter.\\n&quot;, ch); } return 0;} sscan &amp; sprintf用法sscanf：用于从字符串中按照指定的格式读取数据。 函数原型：int sscanf(const char *str, const char *format, ...);参数： str：要读取的字符串。 format：格式说明符，指定了要读取的数据的类型和格式。 后续的参数：指向变量的指针，用于存储读取到的数据。 返回值：成功读取并赋值的参数个数。123456789101112131415161718192021#include &lt;stdio.h&gt;int main() { char input[] = &quot;John 25 1.75&quot;; char name[20]; int age; float height; // 从字符串 input 中按照格式读取数据 int result = sscanf(input, &quot;%s %d %f&quot;, name, &amp;age, &amp;height); if (result == 3) { printf(&quot;Name: %s\\n&quot;, name); printf(&quot;Age: %d\\n&quot;, age); printf(&quot;Height: %.2f\\n&quot;, height); } else { printf(&quot;Failed to read data from the string.\\n&quot;); } return 0;} sprintf：用于按照指定的格式将数据写入字符串。 函数原型：int sprintf(char *str, const char *format, ...); 参数： str：目标字符串，用于存储格式化后的数据。 format：格式说明符，指定了要写入的数据的类型和格式。 后续的参数：要写入的数据。 返回值：写入到字符串中的字符数（不包括终止符 \\0）。12345678910111213141516171819#include &lt;stdio.h&gt;int main() { char buffer[50]; int num = 42; float pi = 3.14159; // 将格式化的数据写入字符串 buffer int result = sprintf(buffer, &quot;The number is %d and the value of pi is %.2f&quot;, num, pi); if (result &gt; 0) { // 输出写入的字符串 printf(&quot;Formatted string: %s\\n&quot;, buffer); } else { printf(&quot;Error in sprintf function.\\n&quot;); } return 0;} 取两个数中较大值或较小值12#define MAX(a, b) ((a) &gt; (b) ? (a) : (b))#define MIN(a, b) ((a) &lt; (b) ? (a) : (b)) qsort用法这个函数接受四个参数： base：指向待排序数组的指针。 nmemb：数组中元素的个数。 size：每个元素的大小（以字节为单位）。 compar：比较函数的指针，用于定义元素之间的比较规则。 比较函数 compar 应该返回一个整数： 如果第一个参数小于第二个参数，返回负数。 如果第一个参数等于第二个参数，返回零。 如果第一个参数大于第二个参数，返回正数。123456789101112131415161718192021222324#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;// 比较函数，用于指定整数的比较规则int compareIntegers(const void *a, const void *b) { return (*(int *)a - *(int *)b);//交换a和b实现降序排列}int main() { int numbers[] = {5, 2, 9, 1, 5, 6}; size_t size = sizeof(numbers) / sizeof(numbers[0]); // 使用 qsort 对整数数组进行排序 qsort(numbers, size, sizeof(numbers[0]), compareIntegers); // 输出排序后的数组 for (size_t i = 0; i &lt; size; ++i) { printf(&quot;%d &quot;, numbers[i]); } printf(&quot;\\n&quot;); return 0;} 判断一个十进制数的二进制表示中有几个“ 1 ”12345678910111213int countOnesInBinary(int num) { int count = 0; // 遍历二进制表示中的每一位 while (num != 0) { if (num % 2 == 1) { count++; } num /= 2; } return count;} 找最大公约数12345678int findGCD(int a, int b) { while (b != 0) { int temp = b; b = a % b; a = temp; } return a;} 二分法查找数组中目标数值的位置123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;stdio.h&gt;// 函数声明int binarySearch(int arr[], int low, int high, int target);int main() { int size; // 从用户输入获取数组大小 printf(&quot;Enter the size of the sorted array: &quot;); scanf(&quot;%d&quot;, &amp;size); int arr[size]; // 从用户输入获取已排序的数组 printf(&quot;Enter the sorted array elements:\\n&quot;); for (int i = 0; i &lt; size; i++) { scanf(&quot;%d&quot;, &amp;arr[i]); } int target; // 从用户输入获取要查找的目标值 printf(&quot;Enter the target value to search: &quot;); scanf(&quot;%d&quot;, &amp;target); // 调用二分查找函数 int result = binarySearch(arr, 0, size - 1, target); // 输出查找结果 if (result != -1) { printf(&quot;Target value %d found at index %d.\\n&quot;, target, result); } else { printf(&quot;Target value %d not found in the array.\\n&quot;, target); } return 0;}// 二分查找函数定义int binarySearch(int arr[], int low, int high, int target) { while (low &lt;= high) { int mid = low + (high - low) / 2; // 检查中间元素是否是目标值 if (arr[mid] == target) { return mid; } // 如果目标值在左半部分，则更新 high if (arr[mid] &gt; target) { high = mid - 1; } // 如果目标值在右半部分，则更新 low else { low = mid + 1; } } // 如果目标值不在数组中，返回 -1 return -1;} 位运算1. 按位与（AND）：&amp; 将两个操作数的对应位进行与操作，结果位为1当且仅当两个操作数对应位都为1。 2. 按位或（OR）：| 将两个操作数的对应位进行或操作，结果位为1当且仅当两个操作数对应位至少有一个为1。 3. 按位异或（XOR）：^ 将两个操作数的对应位进行异或操作，结果位为1当且仅当两个操作数对应位不相等。 4. 按位取反（NOT）：~ 对操作数的每个位取反，即将0变为1，将1变为0。 5. 左移：&lt;&lt; 将操作数的所有位向左移动指定的位数，右侧补零。 6. 右移：&gt;&gt; 将操作数的所有位向右移动指定的位数，左侧补符号位（对于有符号整数）或者补零（对于无符号整数）。 占位符123456789101112131415161718192021#include &lt;stdio.h&gt;int main() { int integerVar = 42; float floatVar = 3.14; char charVar = 'A'; char stringVar[] = &quot;Hello, World!&quot;; int *pointerVar = &amp;integerVar; // 使用占位符输出变量的值 printf(&quot;Integer: %d\\n&quot;, integerVar); printf(&quot;Float: %f\\n&quot;, floatVar); printf(&quot;Char: %c\\n&quot;, charVar); printf(&quot;String: %s\\n&quot;, stringVar); printf(&quot;Pointer: %p\\n&quot;, pointerVar); // 使用 %x 输出整数的十六进制形式 printf(&quot;Integer in Hexadecimal: %x\\n&quot;, integerVar); return 0;} 数据类型及范围整型数据类型 int： 整数类型，通常占用4个字节，表示整数值。范围约为 -2,147,483,648 到 2,147,483,647。 char： 字符类型，占用1个字节，表示单个字符的ASCII码值。范围为 0 到 255 或 -128 到 127（有符号/无符号）。 short： 短整数类型，通常占用2个字节，表示较小范围的整数值。范围约为 -32,768 到 32,767。 long： 长整数类型，占用4或8个字节，表示较大范围的整数值。范围约为 -2,147,483,648 到 2,147,483,647（32位系统）或 -9,223,372,036,854,775,808 到 9,223,372,036,854,775,807（64位系统）。 long long： 更长的整数类型，占用8个字节，表示更大范围的整数值。范围约为 -9,223,372,036,854,775,808 到 9,223,372,036,854,775,807。 浮点型数据类型 float： 单精度浮点数类型，通常占用4个字节，表示小数值。范围约为 1.17549435e-38 到 3.40282347e+38。 double： 双精度浮点数类型，通常占用8个字节，表示更高精度的小数值。范围约为 2.2250738585072014e-308 到 1.7976931348623158e+308。 字符型数据类型 char： 字符类型，占用1个字节，表示单个字符的ASCII码值。范围为 0 到 255 或 -128 到 127（有符号/无符号）。 指针类型 int*： 指向整数的指针类型。 float*： 指向浮点数的指针类型。 char*： 指向字符的指针类型。 数组类型 int[]： 整数数组类型。 float[]： 浮点数数组类型。 char[]： 字符数组类型。 其他类型 void： 表示没有数据类型。 enum： 枚举类型，用于定义一组命名的整数常量。 这些数据类型和范围的信息对于正确使用和存储数据至关重要。请注意，数据范围可能会因编译器和操作系统的不同而有所不同。 转义符在C语言中，转义符（Escape Characters）以反斜杠（\\）开头，用于在字符串常量中表示一些特殊字符或控制字符。以下是一些常见的C语言转义符： \\\\n： 换行符（New Line） 示例：printf(&quot;Hello\\\\nWorld&quot;); \\\\t： 水平制表符（Tab） 示例：printf(&quot;Name:\\\\tJohn&quot;); \\\\r： 回车符（Carriage Return） 示例：printf(&quot;One\\\\rTwo&quot;); \\\\b： 退格符（Backspace） 示例：printf(&quot;Back\\\\bSpace&quot;); \\\\f： 换页符（Form Feed） 示例：printf(&quot;Page 1\\\\fPage 2&quot;); \\\\\\\\： 反斜杠自身 示例：printf(&quot;This is a backslash: \\\\\\\\\\\\&quot;); \\\\\\&quot;： 双引号自身 示例：printf(&quot;He said, \\\\&quot;Hello!\\\\&quot;&quot;); \\\\\\'： 单引号自身 \\\\0： 空字符（Null） 示例：字符串结尾的空字符 '\\\\0' 是C语言字符串的终止符。 \\0 到 \\7：八进制转义字符 示例：printf(&quot;Octal representation: \\\\115&quot;);（表示 'M'） \\x0 到 \\xFF： 十六进制转义字符 示例：printf(&quot;Hex representation: \\\\x4A&quot;);（表示 'J'） 递归函数计算阶乘123456789101112131415161718192021222324#include &lt;stdio.h&gt;// 递归函数计算阶乘unsigned long long factorial(int n) { // 基本情况：当 n 为 0 或 1 时，阶乘为 1 if (n == 0 || n == 1) { return 1; } else { // 递归情况：n 的阶乘等于 n 乘以 (n-1) 的阶乘 return n * factorial(n - 1); }}int main() { int num = 5; // 调用递归函数计算阶乘 unsigned long long result = factorial(num); // 输出结果 printf(&quot;Factorial of %d = %llu\\n&quot;, num, result); return 0;} 判断质数123456789101112131415161718192021222324252627282930313233#include &lt;stdio.h&gt;// 判断一个数是否为质数int isPrime(int number) { if (number &lt;= 1) { return 0; // 1和负数不是质数 } for (int i = 2; i * i &lt;= number; ++i) { if (number % i == 0) { return 0; // 能被整除，不是质数 } } return 1; // 不能被整除，是质数}int main() { int num; // 从用户输入获取一个整数 printf(&quot;Enter a positive integer: &quot;); scanf(&quot;%d&quot;, &amp;num); // 调用函数判断是否为质数并输出结果 if (isPrime(num)) { printf(&quot;%d is a prime number.\\n&quot;, num); } else { printf(&quot;%d is not a prime number.\\n&quot;, num); } return 0;} 冒泡排序升序1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;stdio.h&gt;// 冒泡排序函数（升序）void bubbleSortAsc(int arr[], int n) { for (int i = 0; i &lt; n - 1; ++i) { for (int j = 0; j &lt; n - i - 1; ++j) { // 如果当前元素大于下一个元素，交换它们 if (arr[j] &gt; arr[j + 1]) { int temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; } } }}// 打印数组元素void printArray(int arr[], int size) { for (int i = 0; i &lt; size; ++i) { printf(&quot;%d &quot;, arr[i]); } printf(&quot;\\n&quot;);}int main() { int arr[] = {64, 34, 25, 12, 22, 11, 90}; int n = sizeof(arr) / sizeof(arr[0]); // 输出排序前的数组 printf(&quot;Unsorted array: &quot;); printArray(arr, n); // 调用冒泡排序函数（升序） bubbleSortAsc(arr, n); // 输出排序后的数组 printf(&quot;Sorted array (ascending): &quot;); printArray(arr, n); return 0;} 降序1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;stdio.h&gt;// 冒泡排序函数（降序）void bubbleSortDesc(int arr[], int n) { for (int i = 0; i &lt; n - 1; ++i) { for (int j = 0; j &lt; n - i - 1; ++j) { // 如果当前元素小于下一个元素，交换它们 if (arr[j] &lt; arr[j + 1]) { int temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; } } }}// 打印数组元素void printArray(int arr[], int size) { for (int i = 0; i &lt; size; ++i) { printf(&quot;%d &quot;, arr[i]); } printf(&quot;\\n&quot;);}int main() { int arr[] = {64, 34, 25, 12, 22, 11, 90}; int n = sizeof(arr) / sizeof(arr[0]); // 输出排序前的数组 printf(&quot;Unsorted array: &quot;); printArray(arr, n); // 调用冒泡排序函数（降序） bubbleSortDesc(arr, n); // 输出排序后的数组 printf(&quot;Sorted array (descending): &quot;); printArray(arr, n); return 0;} 大小写转换函数(toupper &amp; tolower)1234567891011121314#include &lt;stdio.h&gt;#include &lt;ctype.h&gt;int main() { char ch = 'A'; // 使用 tolower 将字符转换为小写形式 char lowercaseCh = tolower(ch); printf(&quot;Original character: %c\\n&quot;, ch); printf(&quot;Lowercase character: %c\\n&quot;, lowercaseCh); return 0;}","link":"/2024/07/31/final_summary/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2024/07/30/hello-world/"}],"tags":[],"categories":[],"pages":[]}